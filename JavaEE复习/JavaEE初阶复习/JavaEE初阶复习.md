

1.CPU要执行的指令是在内存中的

冯诺依曼体系结构的基本设定，把执行和存储分开，解耦合，降低硬件设计的成本

2.CPU要想执行指令，就要先取指令，再解析指令，然后才能执行指令

3.取指令需要从内存中读取指令到CPU的寄存器中。取指令的操作很耗时，开销较大，从内存读取数据这件事跟不上越来越快的CPU了，于是设计出缓存

![](JavaEE复习/JavaEE初阶复习/image/img-20251217.png)

# 进程

进程：每个任务/进程在执行过程中都需要消耗一定的硬件资源，**进程是系统分配资源的基本单位**
## 进程在系统中是如何管理的？

1.**先描述**，使用类/结构体这样的方式，把实体属性给列出来
表示进程信息的结构体，叫做PCB（进程控制块，Process Control Block）
2.**再组织**，使用一定的数据结构，把这些结构体/对象串到一起

**一个单核CPU怎么支持一个多任务操作系统运行？**

分时复用（并发）：先执行进程1的代码，执行一会后让进程1下来，让进程2上；进程2执行一段时间后上进程3
### PCB
#### 核心属性

（1）PID：进程的身份标识，通过一个简单不重复的整数来进行区分
（2）内存指针：内存指针是用于描述和定位进程所申请并被操作系统分配的内存空间的一个标识。它记录了进程可访问内存区域的地址信息，用于指示程序在内存中的具体位置。
（3）文件描述符表
我们的进程经常要访问硬盘，而操作系统把硬盘这样的硬件设备封装成了文件
一个进程要想操作文件，需要先打开文件，就是让进程再文件描述符表中分配一个表项（构造一个结构体）来表示这个文件的相关信息
#### 支持进程调度方法

（1）状态：描述某个进程是否能够去CPU上执行
**就绪状态**：随时准备好去CPU上执行
**阻塞状态**：这个进程当前不方便去CPU上执行，不应该调度它（比如进程在等待IO）
（2）优先级：字面理解就是先调度谁，后调度谁的问题
（3）记账信息：针对每个进程占据了多少CPU的时间进行一个统计，并根据这个统计结果进行进一步的调整调度的策略
（4）上下文：这个是支撑进程调度的重要属性，相当于游戏中的存档和读档

所以就需要在进程调度出CPU之前把当前寄存器中的信息保存到内存中，这个就是**存档**
该进程下次再去CPU上执行的时候再把这些寄存器的信息恢复过来（加载到CPU对应寄存器中），这个过程就是**读档**
## 进程的问题

本质上来说，进程可以解决并发编程的问题
但是有些情况下进程表现不尽如人意
1. 如果请求很多，需要频繁的创建和销毁进程的时候，此时使用多进程编程，系统开销就会很大
2. 一个进程刚刚启动的时候，需要把依赖的代码和数据从磁盘加载到内存中

但是从系统分配一个内存不是件容易事情，因为申请内存的时候需要指定大小，系统内部把各种大小的空闲内存，通过一定的数据结构组织起来。实际申请的时候要去这样的空间中查找，找到大小合适的空间，再进行分配

# 线程

线程称为轻量级进程，保持进程的独立调度执行，同时省去了**分配资源**和**释放资源**带来的额外开销

## 进程和线程的关系

1. 进程包含线程
2. 每个线程是一个独立的执行流，可以执行代码并参与CPU调度中（每个线程都有状态，优先级，记账信息和上下文）
3. 每个线程都有自己的资源，进程中的线程共享一份资源
4. 进程和线程之间，不会相互影响。但是如果同一个进程中某个线程抛出异常，可能导致进程中其他线程异常终止
5. 同一个进程中的线程之间会互相干扰，引起线程安全问题
6. 线程太多会导致调度开销过多的问题
7. 线程是系统**调度执行**的基本单位；进程是系统**分配资源**的基本单位

多线程执行

两个线程并发执行，但是这些线程执行的先后顺序是不确定的。
因为操作系统的内核中有一个调度器模块，这个模块的实现方式是一种类似于随机调度的效果
随机调度？（也是抢占式执行）

1. 一个线程什么时候被调度到CPU上执行，时机是不确定的
2. 一个线程什么时候从CPU上下来，给别的线程让位，时机也是不确定的
### 线程创建
#### 1. 继承Thread，重写run

```java
//1. 创建一个自己的类来继承Thread（在java.lang里面，自动导包）
class MyClass extends Thread{
    @Override
    public void run(){
        System.out.println("hello world");
    }
}
public class ThreadDemo1 {
    public static void main(String[] args) {
        //2. 根据刚才的类创建出实例（线程实例才是真正的线程）
        Thread t = new MyClass();
        //3.调用Thread的start方法，才会真正调用API，在系统内核中创建出线程
        //对于同一个Thread对象来说，start只能调用一次
        t.start();
    }
}
```
这里的run类似于main方法，是一个Java进程的入口方法；不需要程序员手动调用，会在合适的时机（线程创建好了之后），被JVM自动调用执行

这种风格的函数被称为**回调函数**
(回调函数是一种特殊的函数，它作为参数传递给另一个函数，并在被调用函数执行完毕后被调用)

#### 2. 实现Runnable接口，重写run

![](JavaEE复习/JavaEE初阶复习/image/img-20251217-1.png)
#### 3. 继承Thread，重写run，但是使用匿名内部类

```java
public class ThreadDemo4 {
    public static void main(String[] args) {
        Thread t = new Thread(){
            @Override
            public void run() {
                while(true){
                    System.out.println("hello thread");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t.start();
        while (true){
            System.out.println("hello main");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

#### 4.  第四种方法：实现Runnable，重写run，实现匿名内部类