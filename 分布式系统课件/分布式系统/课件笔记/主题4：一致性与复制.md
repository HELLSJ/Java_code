# 目录

1. 引言
2. 复制的原因
3. 数据中心一致性模型
4. 操作的一致排序
5. 最终一致性
6. 连续一致性
7. 客户端中心一致性模型
    - 单调读
    - 单调写
    - 读己所写
    - 写随读
8. 副本管理
    - 最优服务器位置选择
    - 内容复制与放置
    - 内容分发
    - 复制对象管理
9. 一致性协议
    - 顺序一致性：基于主副本的协议
    - 顺序一致性：复制写协议
    - 连续一致性的实现
    - 客户端中心一致性的实现
10. 案例：Web中的缓存与复制
    - 协作缓存
    - Web缓存一致性
    - 内容分发网络（CDN）
    - 缓存与复制的替代方案


## 一、引言
### 复制的原因

假设我们对系统的特定部分（包含代码和数据）进行复制，核心目的有两点：
1. **提升可靠性**：若文件系统完成复制，即便其中一个副本崩溃，也可切换至其他副本继续工作；多副本还能有效防范数据损坏。例如，一个文件存在三个副本时，若某次写入操作失败，可采信另外两个副本的结果。
2. **优化性能**：当系统需要在规模或地理范围上进行扩展时，复制能显著增强性能。在规模扩展场景下，若多个进程需访问某台服务器管理的数据，复制服务器并分摊负载可缓解单服务器压力；在地理扩展场景下，将数据副本部署在靠近用户的位置，可缩短访问时延、提升用户感知性能，但可能会消耗更多网络带宽用于副本同步。

### 复制的核心问题

多副本架构的核心挑战在于**一致性维护**——任意副本发生数据变更时，该变更需同步至所有副本，确保所有副本数据状态一致。

以网页访问为例，浏览器为加速访问会在本地缓存页面，再次访问时直接展示缓存版本，但这会导致缓存与源页面的不一致：若源页面已更新，缓存版本无法同步反映变更，用户将无法获取最新内容。

**解决方案**：
1. 完全禁用缓存，所有请求均由源服务器处理，但无就近副本时会导致访问延迟大幅增加。
2. 主动更新或失效缓存副本，但跟踪全网所有缓存并推送更新会严重降低服务器性能。

---

## 二、数据中心一致性模型
### 数据存储的基本概念

数据存储涵盖共享内存、数据库、文件系统等场景下的数据读写操作，其物理层面可分布在多台机器上。假设每个可访问数据存储的进程，都持有整个存储的本地（或就近）副本；当发生写操作时，变更会同步至所有其他副本；仅读取数据的操作为读操作。

### 一致性模型的定义

一致性模型是**数据使用进程与数据存储之间的契约**：若进程遵循特定规则，数据存储将保证数据访问的正确性。例如，进程读取数据时期望获取最新变更，但在无全局时钟的分布式环境中，难以精确定义“最新写操作”，因此衍生出多种一致性模型，规定了数据读取的预期结果。
- 严格一致性模型：易用性强，但性能可能受限。
- 宽松一致性模型：性能更优，但需开发者额外处理一致性问题。
**核心权衡**：严格模型对用户友好但性能不足，宽松模型性能优异但管理复杂度高。

### 操作的一致排序
#### 并行编程中的读写操作表示

- 写操作：$W_i(x)a$ 表示进程$P_i$将值$a$写入数据项$x$
- 读操作：$R_i(x)b$ 表示进程$P_i$从数据项$x$中读取值$b$
所有数据项初始值为$NIL$，可按时间轴简化标识并绘制操作序列。

#### 顺序一致性

**定义**：任何执行的结果，都等价于所有进程的操作按某一顺序串行执行，且每个进程的操作在该序列中保持其程序指定的顺序。
即数据存储的行为如同所有读写操作按固定顺序执行，每个进程按自身程序逻辑感知操作序列，所有进程对操作的感知顺序一致，与操作实际发生的实时时间无关。

**示例分析**：
- 符合顺序一致性的存储：进程$P1$先写$x$为$a$，进程$P2$后写$x$为$b$，进程$P3$和$P4$均先读取到$b$、后读取到$a$，所有进程感知的写操作顺序一致。
- 不符合顺序一致性的存储：$P3$感知到$x$先变为$b$再变为$a$，而$P4$先读取到$a$再读取到$b$，进程间操作顺序感知不一致，违反顺序一致性。
#### 顺序一致性的复杂性

顺序一致性是并发应用开发中最易理解的模型，符合多程序共享数据时的直观预期，但实现难度较大。以两个变量$x$和$y$为例：进程$P1$读取$x$的值为$a$、进程$P2$读取$y$的值为$b$，单看各自操作无异常，但跨数据项组合时，难以找到同时满足两个进程操作顺序的全局序列，体现了顺序一致性在多数据项场景下的局限性。
#### 线性一致性

线性一致性假设操作在其开始和结束时间之间的某一时刻**瞬时完成**。例如，若写操作$W2(y)b$在$W1(y)a$开始前完成，则$y$的最终值为$a$；若$W1(x)a$在$W2(x)b$开始前完成，则$x$的最终值为$b$。
实现线性一致性（尤其在多核系统中）会显著降低性能，但能大幅简化编程，存在**性能与易用性的权衡**。
#### 因果一致性

因果一致性弱于顺序一致性，核心是区分**因果相关事件**与**并发事件**：
- 若事件$b$由事件$a$引发或影响（存在因果关系），则所有进程需先感知$a$、再感知$b$。
- 无因果关系的并发写操作，不同进程可按不同顺序感知。

**规则**：存在潜在因果关系的写操作，必须被所有进程按同一顺序感知；并发写操作可被不同进程按不同顺序感知。
#### 事务与可串行化

事务将一系列读写操作分组，保证操作按序执行。多事务操作同一数据集时，最终结果需等价于事务的某一串行执行顺序，即**可串行化**。

以三个事务为例：
- $T_1: x=0; x=x+1$
- $T_2: x=0; x=x+2$
- $T_3: x=0; x=x+3$

合法调度（如$S1$、$S2$）的最终结果为$x=3$，可等价于$T1→T2→T3$的串行执行；非法调度（如$S3$、$S4$）会产生$x=5$等异常结果。
#### 入口一致性（组操作）

多数一致性模型针对基础读写操作设计，适用于共享内存多处理器系统的硬件实现。应用中通常通过锁等同步机制管理共享数据的并发访问，每个共享数据项关联一个锁，进程进入临界区需获取锁、退出时释放锁。

**核心标准**：
1. 获取锁的前提是其关联共享数据的所有更新已完成。
2. 独占锁的获取需确保无其他进程持有该锁的独占或非独占权限。
3. 非独占锁的获取需确保之前的独占访问（含数据更新）已完成。

入口一致性通过锁的线性化使用保证顺序一致性，关键挑战是**将数据与锁正确关联**，可通过显式声明访问数据或为每个对象绑定唯一锁实现。

### 最终一致性
#### 核心问题

1. 保持副本一致性的关键是确保所有冲突操作在全局按同一顺序执行。
2. 多数数据库系统中，读操作远多于写操作，核心问题是更新需多久对读进程可见。例如，CDN通常选择缓慢传播更新，因多数客户端会定向到同一副本，不易感知不一致。
3. Web场景中，网页由单一主体更新（无写写冲突），浏览器和代理的本地缓存可提升效率，但可能返回过期页面，只要用户持续访问同一缓存，该不一致通常可接受。
#### 冲突操作处理

- **读写冲突**：读与写操作并发执行时，延迟更新传播通常可接受，部分大规模分布式数据库允许一定程度的不一致，其核心特性为**最终一致性**（若一段时间无更新，所有副本将逐渐一致）。
- **写写冲突**：若仅少数进程可执行写操作，冲突易解决（通常选定某一写操作为“胜者”覆盖其他冲突操作），最终一致性实现成本较低；但写写冲突频发时，需通过锁等机制协调进程，这会成为大规模系统的性能瓶颈。

#### 最终一致性的定义

若从某一时刻起无新更新，所有已提交的更新将最终传播到所有副本，使副本数据一致（直到新更新到来）。

#### 扩展模型

1. **强最终一致性**：即使存在冲突更新，发生冲突的副本最终会达到同一状态，可通过全局决议机制（如基于NTP的“最新更新胜出”）解决冲突。
2. **程序一致性**：将一致性焦点从数据转向程序，核心是判断程序执行的协调必要性，避免全局同步。例如，单调问题（输入集扩展时解也扩展，如购物车添加商品）可基于不完整信息执行且无需回滚，仅需在输入集最终确定时协调。

### 连续一致性

连续一致性提出**一致性程度**的概念，允许副本在一定范围内存在差异，主要维度包括：
1. **数值偏差**：适用于股票价格等数值型数据，可定义绝对偏差（如≤0.02美元）或相对偏差（如≤0.5%），只要副本差异在阈值内即视为一致。
2. **陈旧度偏差**：指副本数据的最大允许过期时间，如天气预报数据可容忍数小时的陈旧度，主服务器可定期同步副本。
3. **更新操作偏差**：允许副本间更新操作的数量和顺序存在有限差异，部分更新可先本地试探执行，待全局达成一致后再固化，其难点在于顺序偏差的管理。

**案例**：移动用户的分布式数据库访问
用户在地点A对数据库执行读写操作，切换到地点B后，若连接不同服务器，可能出现以下不一致：A的更新未同步到B、B的新数据未同步到A、A与B的更新最终冲突。用户的核心需求是：在B能看到A操作后的一致数据视图。

---

## 三、客户端中心一致性模型
### 核心定位

数据中心一致性模型保证所有用户看到一致的数据视图，但强一致性的实现会牺牲性能，因此衍生出客户端中心一致性模型——**仅保证单个客户端与数据存储交互的一致性，不保证多客户端并发访问的一致性**，适用于网络连接不可靠的移动计算场景。
客户端通常连接最近的副本执行操作，更新最终异步传播到其他副本。

### 单调读

**定义**：若进程读取到数据项$x$的某一值，后续对$x$的读取必须返回相同值或更新的值（即不会读取到更旧版本）。

**示例**：
- 跨服务器自动同步个人日历，单调读保证用户无论访问哪个服务器，都能看到所有已同步的更新。
- 移动中读取邮件（仅读不修改），从旧金山到纽约切换服务器后，仍能看到旧金山服务器上的所有邮件。

**反例**：若进程先在$L1$读取到$x1$，后在$L2$读取到未包含$x1$变更的$x2$，则违反单调读一致性。
### 单调写

**定义**：进程对数据项$x$的某次写操作，必须在后续对$x$的写操作开始前完成，确保新写操作基于之前的写结果执行（即同一进程的写操作按序执行）。

**示例**：
- 服务器程序更新时，确保编译和链接依赖的所有组件均部署在同一服务器。
- 保证复制文件的版本在全局按正确顺序传播（将旧版本同步到新版本所在服务器）。

**反例**：若进程在$L1$的写操作$x1$未同步到$L2$，进程又在$L2$基于并发版本$x2$执行写操作$x3$，则违反单调写一致性。
### 读己所写

**定义**：进程对数据项$x$执行写操作后，后续对$x$的任何读取（无论访问哪个副本）都必须看到该写操作的结果。

**示例**：更新网页后，浏览器需展示最新版本而非缓存的旧版本；修改密码后，需确保所有服务器同步新密码，避免用户无法立即登录。

**反例**：进程在$L1$写$x1$后，在$L2$读取到未包含$x1$的$x2$，则违反读己所写一致性。

### 写随读

**定义**：进程读取数据项$x$的某一版本后，后续对$x$的写操作必须基于该版本执行，不能覆盖未感知的更新。

### ZooKeeper的一致性模型

ZooKeeper混合了数据中心与客户端中心一致性特性：
1. 保证更新操作的可串行化和顺序性，最终状态可解释为所有更新的某一线性序列，且保留每个客户端的写顺序。
2. 支持单调读，但**不保证读己所写和写随读**。例如，客户端提交写操作后可能仍读取到旧值，读取旧值后提交的写操作也可能被其他客户端的更新覆盖。

## 四、副本管理
### 最优服务器位置选择

核心目标是从$N$个候选位置中选出$K$个最优位置，常见策略包括：
1. 依次选择使客户端平均距离最小的位置（计算成本高）。
2. 选择连接性最好的自治系统部署服务器（计算成本高）。
3. 将节点映射到$d$维几何空间（距离代表延迟），在密度最高的$K$个区域部署服务器（计算成本低）。

**关键考量维度**：

- **服务质量（QoS）**：优化带宽等QoS参数，但延迟、带宽的精确测量难度大，通常需依赖启发式算法。
- **一致性感知**：关注副本更新的传播成本，需预判读写模式。
- **能耗感知**：优化服务器部署以降低能耗，需结合访问模式和网络能力。
- **其他因素**：CDN跨组织部署时需考虑成本和连通性。

### 内容复制与放置
#### 副本的逻辑分类（三层同心环）
1. **永久副本**：进程/机器始终存储的副本。
2. **服务器启动的副本**：应其他服务器请求动态创建的副本。
3. **客户端启动的副本**：应客户端请求动态创建的副本（即客户端缓存）。

#### 动态复制策略

通过统计文件的访问请求（按客户端最近服务器聚合）触发复制、迁移或删除操作：
- 访问量低于阈值$D$：删除副本（保留至少一个全局副本）。
- 访问量高于阈值$R$：复制副本。
- 访问量介于$D$和$R$之间：迁移副本。

例如，若服务器$Q$接收到的文件$F$请求中，超半数来自服务器$P$，则尝试将$F$迁移到$P$；迁移失败且访问量超复制阈值时，将$F$复制到远端服务器。

### 内容分发
#### 基础策略（客户端-服务器模型）
1. **传播更新通知/失效**：仅发送更新通知（不传输数据），带宽消耗极低，适用于读写比低的场景（如频繁更新的大文件）。
2. **传输修改数据**：适用于读写比高的场景，可通过日志打包多修改以降低通信开销。
3. **传播更新操作**：即主动复制，仅发送操作参数（非数据），带宽消耗最小，但需副本具备更强的处理能力，适用于复杂操作的一致性维护。

#### 推送与拉取协议对比
| 维度 | 推送协议（服务器启动） | 拉取协议（客户端启动） |
| --- | --- | --- |
| 服务器状态 | 需维护所有客户端缓存列表（开销大） | 无需维护客户端状态 |
| 消息交互 | 服务器主动推送更新/失效，客户端按需拉取数据 | 客户端轮询服务器，按需拉取更新 |
| 客户端响应时间 | 推送数据时响应时间为0；推送失效时与拉取一致 | 取决于数据拉取耗时，缓存未命中时延迟增加 |

**优化方案**：基于租约动态切换推送/拉取——服务器承诺在租约有效期内主动推送更新，租约过期后切换为拉取模式。租约有效期可自适应调整（如长期未变更的对象租约更长、服务器负载高时租约更短）。

### 复制对象管理
#### 核心问题
1. **并发执行预防**：通过本地锁序列化对象方法的访问，确保同一时间仅一个方法执行。
2. **副本一致性**：需保证所有副本的方法调用按同一顺序执行，多线程服务器需实现**确定性线程调度**（即使中间件保证请求的全局顺序，线程调度也需按序处理同一对象的请求）。

#### 复制对象调用的挑战与解决方案
**挑战**：若复制对象$B$调用另一复制对象$C$，$B$的每个副本会独立调用$C$，导致$C$被重复调用（如金融转账操作重复执行）。

**解决方案**：引入协调器机制：
1. $B$的所有副本为调用请求分配相同唯一标识，由$B$的协调器将请求转发给$C$的所有副本，其他$B$副本暂停请求发送。
2. $C$的协调器处理响应并转发给$B$的所有副本，其他$C$副本暂停响应发送，避免同一请求的重复处理。

---

## 五、一致性协议
### 基于主副本的协议（顺序一致性）
#### 主备协议
每个数据项关联一个主服务器协调写操作（主服务器可固定或迁移到写进程所在节点），读操作可本地执行，写操作流程如下：
1. 进程将写操作发送至主服务器。
2. 主服务器更新本地副本，再将更新转发给备服务器。
3. 备服务器更新副本后向主服务器发送确认。
4. 主服务器收到所有备服务器确认后，向发起进程发送写完成确认。

**变种**：
- **阻塞方式**：需等待所有备服务器确认，写操作延迟高但容错性强，适用于分布式数据库和文件系统。
- **非阻塞方式**：主服务器更新本地副本后立即确认，再异步同步备服务器，写操作更快但容错性降低。

#### 支持本地写的主备协议
写进程可将主副本迁移到本地，执行多轮本地写操作，其他进程可本地读但无法写。适用于移动设备离线场景：设备离线前成为数据主副本，离线时本地处理所有更新，重新联网后同步到备服务器。

### 客户端中心一致性的实现
通过为每个写操作分配全局唯一标识，为每个客户端维护**读集合**（与客户端读操作相关的写标识）和**写集合**（客户端自身的写标识），实现不同一致性：
1. **单调读**：客户端读取时，服务器需确保读集合中的所有写操作已本地执行，未执行则从其他服务器同步或转发请求，读取后将新写标识加入读集合。
2. **单调写**：客户端写操作时，向服务器提交写集合，服务器按序执行集合内写操作后再执行新写操作，新写标识加入写集合（可能增加客户端响应时间）。
3. **读己所写**：客户端读取时，服务器需已执行写集合中的所有写操作，可通过预取更新或定向到已同步的服务器实现。
4. **写随读**：客户端写操作前，先同步读集合中的所有写操作，再执行新写操作并更新写集合。

---

## 六、案例：Web中的缓存与复制
### 缓存层级
1. **客户端缓存**：浏览器本地缓存（简单存储已获取文档）、客户端站点代理缓存（共享缓存，转发请求并缓存响应）；动态文档通常仅缓存不变部分。
2. **ISP缓存**：ISP部署缓存以减少跨ISP流量、提升客户端性能，但多缓存层级可能因缓存未命中增加访问延迟。

### 协作缓存
协作缓存（分布式缓存）中，代理缓存未命中时，先查询相邻代理缓存，无结果再转发请求到Web服务器，适用于同一组织内的Web缓存，其有效性高度依赖客户端请求模式。

与层级缓存相比，协作缓存通过高速链路降低文档获取时间，存储要求更宽松，但小范围客户端场景下，单代理缓存的通信和资源成本更低。

### Web缓存一致性（保证新鲜度）
1. **方案1**：缓存每次访问前联系源服务器确认内容是否最新。
2. **方案2**：为缓存文档分配过期时间$T_{expire}$，公式为$T_{expire}=\alpha(T_{cached}-T_{last modified})+T_{cached}$（通常$\alpha=0.2$），过期前文档视为有效。

### 缓存与复制的替代方案（边缘服务器架构）

边缘服务器处理客户端请求并缓存源服务器数据，源服务器通常为动态生成响应的数据库，核心方案包括：
1. **完全复制**：边缘服务器复制源服务器全部数据，适用于更新频率低、查询复杂的场景；更新频率高时，广域网同步成本会抵消性能收益。
2. **部分复制**：仅复制查询所需的部分数据，适用于单表查询场景；复杂多表查询仍需完全复制。
3. **内容感知缓存**：边缘服务器按查询模板组织本地数据库，匹配到模板时返回缓存结果，未匹配时转发请求并缓存响应，适用于重复查询场景。
4. **内容无感知缓存**：对查询计算哈希值，缓存查询结果，计算开销低但存储可能冗余，需依赖查询模板减少不一致。

---

感谢聆听！
阿伯丁大学（UNIVERSITY OF ABERDEEN）
砥砺前行，成就卓越（MOVE FORWARD. BE GREAT.）

要不要我帮你整理一份**分布式系统一致性与复制核心公式及概念速查表**？