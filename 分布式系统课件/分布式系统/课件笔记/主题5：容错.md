# JC4001：分布式系统
## 主题5：容错
刘孝楠
xiaonan.liu@abdn.ac.uk
阿伯丁大学

## 目录
1. 引言
2. 基本概念
3. 故障模型
4. 基于冗余的故障屏蔽
5. 进程弹性
6. 基于进程组的弹性
7. 故障屏蔽与复制
8. 存在崩溃故障的容错系统共识
9. 存在任意故障的容错系统共识
10. 实现容错的部分限制
11. 故障检测
12. 可靠的客户端-服务器通信
13. 存在故障时的RPC语义
14. 可靠的组通信
15. 分布式提交
16. 恢复
17. 检查点
18. 消息日志

## 1. 引言
### 1.1 基本概念
#### 基础定义
组件是系统中为客户端提供服务的任意部分。为提供这些服务，一个组件可能需要使用其他组件的服务，这意味着组件之间可能存在依赖关系。例如，在Web应用中，前端（用户交互部分）依赖于后端（服务器和数据库）。如果后端发生故障，前端将无法正常工作。

具体来说，若组件C的行为正确性依赖于组件C∗的行为正确性，则称组件C依赖于组件C∗。换句话说，若C∗发生故障，C也将无法正常运行。此处的组件可以是进程（运行中的程序）或通道（进程间的通信链路）。因此，理解这些依赖关系对于设计可靠且容错的系统至关重要。若知晓组件间的依赖关系，就能更好地管理故障，确保系统整体平稳运行。

#### 可靠系统的相关需求
容错系统是可靠系统的一部分，其相关需求如下表所示：

| 需求 | 描述 |
| ---- | ---- |
| 可用性 | 随时可供使用的状态 |
| 可靠性 | 服务交付的连续性 |
| 安全性 | 极低的灾难性事件发生概率 |
| 可维护性 | 故障系统的修复难易程度 |

- **可用性**：指系统在任意时刻都处于可使用状态。它表示系统在用户需要时能正确工作并执行其功能的概率。简单来说，高可用性系统就是在你需要时几乎始终处于运行状态的系统。
- **可靠性**：指系统能够持续运行而不发生故障。与可用性不同，可靠性是在一段时间内衡量的。因此，高可靠性系统是指能够长时间不间断工作的系统。例如，若一个系统每小时宕机1毫秒，其可用性极高（超过99.9999%），但可靠性仍然较差；而一个从不崩溃但每年8月停机两周的系统，可靠性极高，但可用性仅为96%。两者的区别显而易见。
- **安全性**：确保即使系统暂时发生故障，也不会出现灾难性后果。这对于控制核电站或太空任务等的系统尤为重要，此类系统的短暂故障可能导致灾难性后果。构建真正安全的系统极具挑战性。
- **可维护性**：指故障系统的修复难易程度。易于修复的系统通常能保持高可用性，尤其是当它能够自动检测和修复故障时。然而，正如我们将看到的，故障的自动恢复说起来容易做起来难。

#### 可用性与可靠性的量化定义
- **组件C的可用性$A(t)$**：指组件在特定时间段内正常工作的时间占比。形式上，我们将组件在0到t时间间隔内的可用性$A(t)$定义为该组件在该间隔内正常工作的平均时间占比。若考虑长期可用性，则关注$A(∞)$，即组件在无限时间内的可用性。
- **组件C的可靠性$R(t)$**：指组件在特定时间段内持续正常工作的可能性。传统上，我们将组件在0到t时间间隔内的可靠性$R(t)$定义为：假设组件在初始时刻（$T=0$）正常工作，在该时间段内持续正常工作的概率。

可用性关注组件的运行时间占比，而可靠性关注组件在一段时间内的持续运行能力，两者对于理解系统的可靠性都至关重要。

#### 传统指标
- **平均无故障时间（MTTF）**：组件发生故障前的平均工作时间，可视为组件的预期寿命。
- **平均修复时间（MTTR）**：组件发生故障后修复所需的平均时间，反映了系统恢复运行的速度。
- **平均故障间隔时间（MTBF）**：即$MTTF + MTTR$，表示两次故障之间的平均时间。

#### 可用性公式
长期可用性$A = A(∞)$，满足：
$A=\frac{MTTF}{MTBF}=\frac{MTTF}{MTTF+MTTR}$

#### 关键观察
只有准确理解故障的定义，可靠性和可用性才有意义。

#### 故障、错误与缺陷的定义
- **故障（Failure）**：系统未达成预期目标时称为发生故障。例如，若分布式系统应向用户提供多项服务，但其中一项或多项服务无法完全交付，则系统发生故障。
- **错误（Error）**：指系统状态中可能导致故障的部分。例如，通过网络发送数据包时，部分数据包可能损坏，导致接收方读取错误的比特值（如将0读为1）或完全无法检测到数据包，这就是错误。
- **缺陷（Fault）**：指错误的成因。例如，传输介质故障可能导致数据包损坏，更换介质即可直接修复；但如果错误是由无线网络中的恶劣天气导致的，修复“天气”则难度较大！

再举一个例子：程序崩溃是一种故障，可能是由于程序运行到有缺陷的代码段。该缺陷代码是错误，而引入该缺陷的程序员是缺陷的成因。因此，程序员间接导致了崩溃。

#### 缺陷的分类与应对策略
构建可靠系统的核心是控制缺陷，可通过预防、容忍、消除或预测缺陷来实现。关键在于容错——确保系统即使存在缺陷也能正常工作。例如，在数据包传输中使用纠错码有助于系统容忍较差的传输线路，降低损坏数据包导致故障的概率。

缺陷通常分为三类：瞬时缺陷、间歇性缺陷和永久性缺陷。

| 术语 | 描述 | 示例 |
| ---- | ---- | ---- |
| 故障 | 组件未达到其规格要求 | 程序崩溃 |
| 错误 | 可能导致故障的组件状态 | 程序漏洞 |
| 缺陷 | 错误的成因 | 粗心的程序员 |

- **瞬时缺陷（Transient faults）**：发生一次后即消失，再次执行操作时通常能正常工作。例如，鸟类飞过微波传输波束导致部分比特丢失，重新传输通常能成功。
- **间歇性缺陷（Intermittent faults）**：自行出现和消失，通常由松动的连接器等导致。这类缺陷难以诊断，因为维修人员到场时系统可能恢复正常。
- **永久性缺陷（Permanent faults）**：持续存在，直至故障组件被更换。例如，烧毁的芯片、软件漏洞和磁头崩溃等。

#### 缺陷应对策略
| 策略 | 描述 | 示例 |
| ---- | ---- | ---- |
| 缺陷预防 | 防止缺陷发生的技术，如使用高质量组件和严格测试 | 不雇佣粗心的程序员 |
| 容错 | 构建组件以屏蔽缺陷的影响，如备份系统、纠错码 | 由两名独立程序员开发同一组件 |
| 缺陷消除 | 识别并修复系统中已存在的缺陷，如定期维护和更新 | 解雇粗心的程序员 |
| 缺陷预测 | 预测缺陷可能发生的位置并提前处理，如数据分析 | 评估招聘人员在避免雇佣粗心程序员方面的表现 |

## 2. 故障模型
系统发生故障的原因可能是服务器、通信通道或两者均未正常工作。此外，若故障服务器依赖其他服务器完成工作，则问题可能出在其他地方。

分布式系统中这种依赖关系很常见。例如，磁盘故障可能导致依赖该磁盘提供高可用文件系统的文件服务器出现问题；若该文件服务器是大型分布式数据库的一部分，则由于部分数据无法访问，整个数据库可能受到影响。

### 2.1 故障类型分类
| 故障类型 | 描述 |
| ---- | ---- |
| 崩溃故障（Crash failure） | 系统停止工作，但停止前工作正常 |
| 遗漏故障（Omission failure） | 未响应传入请求 |
| 接收遗漏（Receive omission） | 未接收传入消息 |
| 发送遗漏（Send omission） | 未发送消息 |
| 时序故障（Timing failure） | 响应超出指定时间间隔 |
| 响应故障（Response failure） | 响应不正确 |
| 值故障（Value failure） | 响应值错误 |
| 状态转换故障（State-transition failure） | 偏离正确的控制流 |
| 任意故障（Arbitrary failure） | 可能在任意时间产生任意响应 |

#### 各类故障的详细说明
- **崩溃故障（Crash Failure）**：服务器完全停止工作且不再通信。典型示例是操作系统崩溃，唯一的解决方法是重启。个人电脑常出现这种情况，因此机箱正面通常设有重置按钮。
- **遗漏故障（Omission Failure）**：服务器未响应请求，分为两种类型：
  - 接收遗漏故障（Receive-Omission Failure）：服务器未收到请求，可能是因为没有线程监听传入请求。
  - 发送遗漏故障（Send-Omission Failure）：服务器完成工作但未发送响应，可能是由于发送缓冲区溢出。这种情况下，服务器需准备好处理客户端的请求重发。
- **时序故障（Timing Failure）**：服务器的响应过早或过晚。例如，视频流中数据到达过早或过晚会导致播放问题。常见的时序故障是性能故障，即响应过晚。
- **响应故障（Response Failure）**：服务器的响应不正确，分为两种类型：
  - 值故障（Value Failure）：服务器对请求给出错误答案。例如，搜索引擎返回不相关结果。
  - 状态转换故障（State-Transition Failure）：服务器对请求的反应异常。例如，服务器收到无法识别的消息并采取不适当的操作。
- **任意（拜占庭）故障（Arbitrary (Byzantine) Failure）**：最严重的故障类型，服务器产生无法检测为错误的不正确输出，不可预测且可能导致严重问题。

### 2.2 遗漏故障与执行故障的区分
任意故障通常与进程的恶意行为相关，但故障是恶意的还是单纯的错误并不总是明确的。例如，操作系统设计不良的计算机对其他计算机产生负面影响，是恶意行为还是设计缺陷？由于这种不确定性，更适合使用不涉及主观判断的区分方式：
- **遗漏故障（Omission failures）**：组件未执行应执行的操作。例如，服务器未按要求发送响应。
- **执行故障（Commission failure）**：组件执行了不应执行的操作。例如，服务器发送错误响应。

#### 关键观察
蓄意故障（可能是遗漏故障或执行故障）通常属于安全问题，一般无法区分蓄意故障和无意故障。

### 2.3 异步系统与同步系统中的故障检测
- **场景**：组件C不再感知到C∗的任何活动——这是停止故障吗？可能无法区分崩溃故障、遗漏故障或时序故障。
- **异步系统**：对进程执行速度或消息传递时间无假设，无法可靠检测崩溃故障。
- **同步系统**：进程执行速度和消息传递时间有界，可可靠检测遗漏故障和时序故障。
- **实际系统**：多为部分同步系统——大多数情况下可假设系统是同步的，但系统处于异步状态的时间无界，通常可可靠检测崩溃故障。

### 2.4 停止故障类型
| 停止类型 | 描述 |
| ---- | ---- |
| 故障停止（Fail-stop） | 崩溃故障，可可靠检测 |
| 故障发声（Fail-noisy） | 崩溃故障，最终可可靠检测 |
| 故障静默（Fail-silent） | 遗漏故障或崩溃故障，客户端无法判断问题原因 |
| 故障安全（Fail-safe） | 任意但无害的故障（不会造成任何损害） |
| 任意故障（Fail-arbitrary） | 任意故障，包括恶意故障 |

#### 各类停止故障的详细说明
- **故障停止故障（Fail-Stop Failures）**：可可靠检测的崩溃故障。例如，假设通信链路无故障，进程P可为进程Q的响应设置最大延迟，若Q未在该时间内响应，则P判定Q崩溃。
- **故障发声故障（Fail-Noisy Failures）**：与故障停止故障类似，但P需经过一段时间才能确定Q崩溃，在此期间检测结果不可靠。
- **故障静默故障（Fail-Silent Failures）**：假设通信链路正常，但P无法判断Q是崩溃还是发生遗漏故障（如丢失消息）。
- **故障安全故障（Fail-Safe Failures）**：Q发生任意故障但无危害，不会造成损害。
- **任意故障（Fail-Arbitrary Failures）**：Q可能以任何方式故障，包括无法检测且对其他进程的正确行为造成损害的方式，是最严重的故障类型。

## 3. 基于冗余的故障屏蔽
要使系统具备容错能力，目标是尽可能向其他进程隐藏故障。故障屏蔽的关键技术是冗余，主要分为以下三类：

### 3.1 信息冗余（Information redundancy）
通过添加额外数据位来恢复错误。例如，在传输数据中添加汉明码，可恢复传输线路上的噪声导致的错误。

### 3.2 时间冗余（Time redundancy）
执行某项操作，必要时重复执行。例如，事务失败时可重试（因事务未最终确定，重试无负面影响）；若未收到服务器响应，可重新发送请求。时间冗余对瞬时或间歇性故障尤为有效。

### 3.3 物理冗余（Physical redundancy）
添加额外的硬件或进程，以容忍部分组件的丢失或故障。例如，添加额外进程，即使部分进程崩溃，系统仍能正常运行。这种冗余可通过硬件或软件实现，通过进程复制可实现高度容错。

## 4. 进程弹性
### 4.1 基于进程组的弹性
#### 核心思想
通过进程复制保护系统免受进程故障的影响，将多个进程组织成进程组。处理故障进程的主要策略是将多个相同的进程组织成组，其关键特性是：向组发送消息时，所有成员都会接收。这样，若一个进程故障，另一个进程可接管工作。

进程组可以是动态的：可创建新组、销毁旧组，进程可在运行时加入或退出组，一个进程甚至可同时属于多个组。因此，需要机制管理组及其成员资格。组的目的是让一个进程能与其他多个进程的集合交互，就像与单个实体交互一样。例如，进程P可向组$Q={Q_1, Q_2, ..., Q_N}$发送消息，无需知道成员的身份、位置或数量，对P而言，组Q就像一个单一的逻辑进程。

#### 进程组的类型
- **扁平组（Flat Group）**：所有进程地位平等，无领导者，集体决策。若一个进程崩溃，组规模缩小但继续运行。缺点是决策速度较慢，通常需要投票。
- **层次组（Hierarchical Group）**：包含一个协调器（或领导者）和多个工作者。协调器处理请求并将任务分配给工作者，决策速度更快，但协调器故障时，整个组将停止工作，直至选举出新的协调器。例如，域名系统（DNS）和主备模式均属于层次组。

#### 组成员管理
- **集中式管理**：使用组服务器处理所有加入或退出组的请求，服务器维护所有组及其成员的数据库。该方法简单高效，但存在单点故障风险——若组服务器崩溃，组管理停止，所有组可能需要重建。
- **分布式管理**：成员集体管理组。例如，进程可通过广播消息申请加入组；退出组时，向所有成员发送告别消息。但检测进程崩溃较复杂，需其他成员通过进程停止响应来判断。

#### 同步机制
当进程加入或退出组时，该操作必须与正在进行的数据消息同步：新成员需从加入时刻起接收所有组消息，退出成员需立即停止接收消息。这可通过将加入或退出操作视为发送给整个组的消息来管理。

#### 多故障处理
若多个进程故障，组可能停止运行。需通过协议重建组，通常涉及某个进程主导重建过程。协议需处理多个进程同时竞争主导权的情况，可能采用领导者选举算法。

### 4.2 故障屏蔽与复制
#### k-容错组
指能屏蔽任意k个并发成员故障的组（k称为容错度）。若系统能处理k个组件的故障并仍正常运行，则称该系统为k-容错系统。

#### k-容错组的规模要求
- **停止故障（崩溃/遗漏/时序故障）**：需$k+1$个成员。因无成员产生错误结果，单个成员的结果即可满足要求，即使k个成员停止工作，剩余1个成员的响应仍可使用。
- **任意故障**：需$2k+1$个成员。通过多数投票获得正确结果，最坏情况下，k个故障进程可能产生相同的错误响应，但剩余$k+1$个进程将产生正确响应，客户端可信任多数结果。

#### 重要假设
- 所有成员完全相同。
- 所有成员按相同顺序处理命令。

### 4.3 存在崩溃故障的容错系统共识
#### 前提假设
在客户端-服务器模型中，大量客户端向一组进程发送命令，这些进程协同工作，如同一个超级可靠的单一进程。要实现这一点，需满足以下重要假设：

在容错进程组中，每个无故障进程必须与其他所有无故障进程执行相同的命令，且命令执行顺序一致。

#### 问题重构
无故障组成员需就下一步执行的命令达成共识。无故障时，达成共识较简单（例如，使用Lamport的全序多播或集中式定序器为每个命令分配序列号）。但实际中存在故障，进程组达成共识变得复杂。

#### 基于泛洪的共识算法（Flooding-based Consensus）
- **系统模型**：
  - 进程组$P={P_1, ..., P_n}$。
  - 采用故障停止语义（即可靠检测进程崩溃）。
  - 客户端向某个$P_i$发送命令执行请求，每个$P_i$维护提议命令列表。
- **基本算法（基于轮次）**：
  1. 每轮中，进程$P_i$向组内所有其他进程发送其提议命令列表。
  2. 轮次结束时，每个进程将收到的所有提议命令合并为新列表。
  3. 每个进程从新列表中确定性地选择可执行的命令（若有）。

- **关键观察**：
  - 无故障时算法运行良好，但进程崩溃时会出现问题。例如，进程组包含$P_1,P_2,P_3,P_4$，$P_1$在轮次r中崩溃，$P_2$在其崩溃前收到了$P_1$的提议命令列表，但$P_3$和$P_4$未收到。
  - $P_2$拥有所有提议命令，可做出决策；而$P_3$和$P_4$无法确定$P_2$是否收到$P_1$的命令，因此无法做出决策。
  - $P_3$和$P_4$需等待下一轮，仅当收到所有无故障进程的消息后才进入下一轮（依赖可靠故障检测确定活跃进程）。
  - $P_2$可广播其决策，$P_3$和$P_4$在下一轮（r+1）中执行相同命令。最坏情况下，仅剩一个无故障进程时，该进程可单独决定执行的命令。
  - 若$P_2$的决策消息丢失，$P_2$（未崩溃时）可重传；若$P_2$崩溃，$P_4$检测到后可重广播决策，$P_3$在下一轮收到后完成算法。

#### Raft共识协议
Raft是适用于崩溃故障的共识协议，进程最终能检测到其他进程的崩溃。

- **系统模型**：
  - 通常包含约5个复制服务器，服务器集固定（允许动态加入/退出）。
  - 每个服务器维护操作日志（含已提交和未提交操作），目标是使所有服务器的日志达成共识（已提交操作在所有服务器日志中的位置一致）。
  - 一个服务器作为领导者，决定未提交操作的提交顺序。
- **核心流程**：
  1. **客户端请求**：客户端向领导者发送操作请求，领导者将请求以$\langle 操作, 任期, 索引 \rangle$的形式追加到日志中（任期为领导者当前服务的任期，索引为日志中的位置）。
  2. **日志复制**：领导者向其他服务器发送其完整日志（概念上）及最新已提交操作的索引，追随者复制日志并在确认执行完索引前的所有操作后发送确认。
  3. **提交**：领导者收到多数追随者的确认后，提交该操作，通知客户端，并更新已提交操作的索引，追随者根据该索引提交操作。
  4. **领导者崩溃**：新领导者通过选举产生，其日志成为服务器组的集体状态。选举时，日志较新（已提交操作更多或包含更新任期的操作）的服务器不会投票给日志较旧的候选者。
- **关键特性**：新领导者的状态与崩溃前的旧领导者状态一致；客户端未收到响应时重发请求，确保无请求丢失。
- **领导者崩溃后的处理**：若领导者执行操作$o_1$后未通知所有服务器即崩溃，新领导者的日志包含多数服务器的已提交操作，缺失的提交操作将被发送给其他追随者。例如，新领导者处理操作$o_2$时，广播其日志，收到多数确认后可同时提交$o_1$和$o_2$。

#### Paxos算法示例
- **假设条件**（弱且符合实际）：
  - 部分同步系统（甚至可异步）。
  - 进程间通信不可靠（消息可能丢失、重复或乱序）。
  - 可检测损坏的消息（进而忽略）。
  - 所有操作是确定性的。
  - 进程可能发生崩溃故障，但不会发生任意故障。
  - 进程不串通。
- **进程类型**：
  - 客户端（Clients）：请求特定操作。
  - 提议者（Proposers）：代表客户端在服务器端尝试让客户端请求被接受。
  - 接受者（Acceptors）：决定是否接受提议的操作。
  - 学习者（Learners）：一旦多数接受者同意，执行选定的操作。
- **核心流程**（简化）：
  - 领导者（主提议者）接收客户端请求，向所有接受者发送提议。
  - 同意提议的接受者广播学习消息。
  - 学习者收到多数相同的学习消息后，执行该操作。
- **关键问题与解决方案**：
  1. **执行保障**：仅达成共识不够，需确保多数无故障服务器实际执行操作。通过重传学习消息和接受者记录决策来实现，确保操作按序执行。
  2. **领导者故障**：新领导者通过选举产生，故障领导者恢复后需识别新领导者。Paxos容忍多个提议者同时认为自己是领导者，需通过区分提议确保仅当前领导者的提议被接受，因此需集成领导者选举算法。
- **核心思想**：通过复制服务器并确保所有客户端命令按相同顺序执行来提高可靠性。领导者（主服务器）为命令分配唯一时间戳，追随者（备份服务器）按时间戳执行命令。
- **关键术语**：
  - 领导者向备份服务器发送$ACCEPT(o, t)$消息，为命令o分配时间戳t。
  - 备份服务器响应$LEARN(o, t)$消息。
  - 领导者发现操作o未被学习时，重传带有原始时间戳的$ACCEPT(o, t)$。
- **故障处理**：
  - 主服务器执行操作后崩溃，备份服务器未收到$ACCEPT$消息：服务器仅在确认其他服务器已学习该操作后才执行。
  - 学习消息丢失：例如，$S_2$发送的$LEARN(o^1)$消息丢失，$S_2$需等待$S_3$学习$o^1$后再执行$o^1$。
  - 可靠故障检测的局限性：实际中无法可靠检测故障，需使用超时机制，但可能产生误检测。解决方案：引入额外服务器，要求服务器仅在知道多数服务器将执行该操作时才执行，例如三服务器架构中，服务器收到至少一个其他服务器的$LEARN$消息后执行操作。
- **关键观察**：
  - Paxos至少需要三个服务器。
  - 三服务器架构中，单个服务器崩溃时，Paxos仍能正确工作，无论崩溃发生在何时。
  - 领导者需在消息中包含ID，避免延迟消息导致的混淆；新领导者接管时需确保旧领导者的未完成操作已处理，通过显式的领导者接管机制通知其他服务器。

### 4.4 存在任意故障的容错系统共识
#### 核心问题
考虑进程间通信不一致的进程组，例如：
- 错误转发：进程P2转发与应转发的值或操作不同的内容。
- 不一致消息：进程P1向不同进程发送不同消息（如向部分备份发送操作o，向其他备份发送操作o′）。

这些不一定是恶意行为，可能是遗漏或执行故障。

#### 共识的必要条件
若进程组中有k个成员可能发生任意故障，要达成共识，进程组规模至少为$3k + 1$。

#### 系统模型与拜占庭协议要求
- **系统模型**：
  - 包含1个主服务器P和$n-1$个备份服务器$B_1, ..., B_{n-1}$。
  - 客户端向主服务器P发送值$v \in \{T, F\}$。
  - 消息可能丢失，但可检测。
  - 消息损坏可检测。
  - 接收方可可靠识别消息发送方。
- **拜占庭协议要求**：
  - BA1：所有无故障备份服务器存储相同的值。
  - BA2：若主服务器无故障，则所有无故障备份服务器存储主服务器发送的确切值。

#### 小规模进程组的共识局限性
- 两服务器架构（1主1备）：主服务器故障时发送不一致值，或备份服务器故障时转发错误值，均无法达成共识。
- 三服务器架构（1主2备）：主服务器故障发送不一致值，备份服务器收到$\{T, F\}$，无法达成共识；备份服务器故障转发错误值，另一备份服务器收到$\{T, F\}$，无法满足BA2要求。

#### 3k+1进程组的共识实现
以$n=4$（$k=1$）为例，1个主服务器P和3个备份服务器$B_1, B_2, B_3$：
- 主服务器故障：P向$B_1$发送T，向$B_2$发送F，向$B_3$发送T。备份服务器转发收到的值，两轮消息交换后，每个备份服务器收到$\{T, T, F\}$，通过多数投票达成共识（T）。
- 备份服务器故障：主服务器向所有备份发送T，$B_2$故障发送F。$B_1$和$B_3$转发T，最终$B_1$和$B_3$判定主服务器发送T，满足BA2要求。

#### 实用拜占庭容错（PBFT）协议
- **背景**：首个在保证性能的同时实现拜占庭容错的解决方案，随着许可区块链的出现而普及。
- **假设条件**：
  - 服务器可能发生任意故障。
  - 消息可能丢失、延迟或乱序。
  - 消息带有可识别的发送方签名。
  - 部分同步执行模型。
- **核心思想**：采用主备模式，包含$3k + 1$个副本服务器。
- **核心流程**（四阶段）：
  1. **预准备（PRE-PREPARE）**：客户端C向主服务器P发送操作o执行请求；P记录当前视图v（跟踪无故障副本），为o分配时间戳t（逐请求递增），发送带签名的预准备消息$PRE-PREPARE(t, v, o)$给所有备份服务器。
  2. **准备（PREPARE）**：无故障备份服务器在当前视图v且未接受相同时间戳t的操作时，接受预准备消息，并向所有服务器（含主服务器）发送带签名的准备消息$PREPARE(t, v, o)$。
  3. **提交（COMMIT）**：无故障服务器收集到$2k$个匹配预准备消息的准备消息（含自身）后，达成操作顺序共识，广播提交消息$COMMIT(t, v, o)$。
  4. **响应（REPLY）**：服务器收集到$2k$个提交消息（不含自身）后，安全执行操作o并向客户端回复结果。
- **视图切换**：
  - 当备份服务器检测到主服务器故障时，广播视图切换消息$viewchange(v + 1, P)$（P为其准备证书集合）。
  - 新主服务器由所有备份服务器已知的确定性函数选出，需收到$2k + 1$个视图切换消息（形成视图切换证书X），然后广播新视图消息$new-view(v + 1, X, O)$（O包含基于X中准备证书生成的新预准备消息）。
  - 新视图中的备份服务器验证O和X，广播准备消息，恢复共识流程。

## 5. 实现容错的部分限制
### 5.1 性能开销
进程组复制虽能提高容错能力，但可能以性能为代价。例如，容错组中的进程可能需要交换大量消息才能做出决策（如拜占庭协议），导致性能问题，甚至在某些情况下无法实现容错。

### 5.2 共识的局限性
#### 共识的正式要求
- 所有进程产生相同的输出值。
- 每个输出值必须有效。
- 每个进程最终必须提供输出。

#### 共识的应用场景
包括选择协调器、事务决策、任务分配等。无故障时达成共识较简单，但故障情况下，分布式共识算法需在有限步骤内使所有无故障进程达成共识，而不同的系统假设（同步/异步、通信延迟、消息顺序等）需要不同的解决方案，部分场景下甚至不存在解决方案。

#### 系统模型分类
| 进程行为 | 消息顺序 | 通信延迟 | 消息传输 |
| ---- | ---- | ---- | ---- |
| 同步 | 有序/无序 | 有界/无界 | 单播/多播 |
| 异步 | 有序/无序 | 有界/无界 | 单播/多播 |

- **同步系统**：进程按固定步长运行，存在常数c，若任一进程执行了c+1步，则其他所有进程至少执行了1步。
- **异步系统**：对进程执行速度和消息传递时间无假设。
- **通信延迟**：有界（消息在全局已知的最大时间内交付）或无界。
- **消息顺序**：保证按发送顺序交付或无此保证。
- **消息传输**：单播（点对点）或多播（一对多）。

### 5.3 CAP定理
#### 核心内容
任何提供共享数据的网络系统最多只能满足以下三个特性中的两个：
- C（一致性，Consistency）：共享复制数据项呈现为单一的最新副本。
- A（可用性，Availability）：更新操作最终将被执行。
- P（分区容错性，Partition tolerance）：容忍进程组分区（如网络故障）。

#### 结论
在存在通信故障的网络中，无法实现保证对每个请求做出响应的原子读写共享内存。

## 6. 故障检测
### 6.1 核心问题
如何可靠检测进程是否真正崩溃？

### 6.2 通用模型
- 每个进程配备故障检测模块。
- 进程P向进程Q发送探测请求，等待响应。
- 若Q响应，则P认为Q存活。
- 若Q在t时间内未响应，则P怀疑Q崩溃。

### 6.3 同步系统中的特性
在同步系统中，怀疑崩溃等同于确定崩溃。

### 6.4 实现方式
- 若P在时间t内未收到Q的心跳消息，则P怀疑Q崩溃。
- 若Q之后发送消息并被P接收，则P停止怀疑Q，并增加超时时间t。
- 注意：若Q确实崩溃，P将持续怀疑Q。

## 7. 可靠的客户端-服务器通信
### 7.1 存在故障时的RPC语义

远程过程调用（RPC）的目标是使远程调用与本地调用具有相同的体验，但故障情况下会出现问题。

#### RPC系统中的故障类型
1. 客户端无法定位服务器。
2. 客户端到服务器的请求消息丢失。
3. 服务器收到请求后崩溃。
4. 服务器到客户端的响应消息丢失。
5. 客户端发送请求后崩溃。

#### 简单解决方案
- 故障1（无法定位服务器）：直接向客户端报告错误。
- 故障2（请求丢失）：重发消息。

#### 服务器崩溃的处理
服务器崩溃分为三种情况：
- (a) 正常情况：请求到达→处理→发送响应。
- (b) 处理请求后、发送响应前崩溃：无响应。
- (c) 接收请求前崩溃：无响应。

客户端无法区分情况(b)和(c)，因此有两种处理策略：
- **至少一次语义（At-least-once-semantics）**：持续重试直到收到响应，确保请求至少被处理一次，但可能多次处理。
- **最多一次语义（At-most-once-semantics）**：立即放弃并报告故障，确保请求最多被处理一次，但可能未被处理。

#### 理想语义的不可能性
完全透明的服务器恢复是不可能的，因为客户端无法确定服务器是在完成操作前还是后崩溃。例如，文档处理请求中，服务器崩溃后恢复，客户端无法知晓请求是否已完成。四种可能的策略各有缺陷：
1. 从不重发请求：可能导致文档未被处理。
2. 总是重发请求：可能导致文档被重复处理。
3. 未收到确认时重发：假设服务器未收到请求，但可能服务器已处理但未发送确认。
4. 收到确认时重发：假设服务器已收到请求但未处理，但可能服务器已处理。

#### 服务器事件的可能顺序
假设服务器被请求更新文档，存在三种事件：M（发送完成消息）、P（完成文档处理）、C（崩溃），共六种可能的顺序：
1. $M \to P \to C$：发送完成消息→处理文档→崩溃。
2. $M \to C \to P$：发送完成消息→崩溃→未完成处理。
3. $P \to M \to C$：处理文档→发送完成消息→崩溃。
4. $P \to C(\to M)$：处理文档→崩溃→未发送完成消息。
5. $C(\to P \to M)$：崩溃→未处理文档→未发送完成消息。
6. $C(\to M \to P)$：崩溃→未发送完成消息→未处理文档。

#### 丢失响应消息的处理
- **核心问题**：客户端无法区分响应丢失、请求丢失或服务器崩溃。
- **部分解决方案**：
  1. 设计幂等操作：重复执行同一操作无副作用，但部分操作（如银行转账）非幂等，重复执行会导致错误（如双重转账）。
  2. 客户端为每个请求分配序列号，服务器记录每个客户端的最新序列号，识别重复请求并避免重复执行。服务器需维护客户端请求记录，且需确定记录的保留时间；可在消息头中添加标记区分初始请求和重发请求。

#### 客户端崩溃的处理
客户端发送请求后崩溃，服务器仍在执行操作，导致“孤儿计算”，浪费资源、锁定文件或造成混淆（如客户端重启后收到孤儿计算的响应）。解决方案包括：
- **孤儿终止（Orphan Extermination）**：客户端发送RPC前记录操作，崩溃重启后检查日志并终止孤儿进程。缺点是日志写入开销大，追踪孤儿进程及其子进程复杂。
- **重生（Reincarnation）**：将时间划分为编号的时期，客户端恢复后广播新时期消息，终止所有旧时期的远程计算。网络分区时可能有孤儿进程存活，但可通过时期编号检测。
- **温和重生（Gentle Reincarnation）**：收到时期广播后，各机器检查远程计算并尝试找到其所有者，仅在找不到所有者时终止计算。
- **过期（Expiration）**：为每个RPC设置超时时间T，超时未完成需申请延长；客户端崩溃后，等待T时间确保所有孤儿进程终止。难点是选择合理的T值。

## 8. 可靠的组通信
### 8.1 核心思想
向进程组G发送的消息应交付给G的每个成员，需区分消息的接收和交付：
- **接收（Reception）**：消息被进程的网络层接收。
- **交付（Delivery）**：消息被进程的应用层处理。

可靠组通信的目标是：消息发送到进程组后，所有无故障成员都能接收并交付该消息。可通过消息处理组件分离消息处理与组成员的核心操作，确保消息按序交付。

### 8.2 组成员变更的影响
发送者希望消息交付给组G，但交付时组已变更为G′，需决定是否交付该消息。若忽略组成员共识，可简化通信：发送者维护接收者列表，使用TCP等可靠协议逐一向接收者发送消息；接收者故障时，可稍后重发或忽略（若发送者已退出组）。

### 8.3 可靠组通信的实现方式（针对非故障进程）
大多数传输层擅长可靠点对点通信，但不支持可靠多播（消息需交付给所有目标接收者）。小范围组可通过以下方式实现可靠多播：
1. 发送者为每个多播消息分配序列号，并将消息存储在本地历史缓冲区。
2. 发送者保留消息直到收到每个接收者的确认。
3. 接收者发现缺失特定序列号的消息（如收到更高序列号的消息）时，发送否定确认，请求重发。

### 8.4 存在故障进程时的可靠组通信
核心要求：消息需被所有无故障组成员接收并交付。关键挑战是交付消息前需就组成员构成达成共识。

## 9. 分布式提交
### 9.1 核心问题
确保进程组的每个成员要么都执行某个操作，要么都不执行（原子性）。例如：
- 可靠多播：消息需交付给所有接收者。
- 分布式事务：每个参与站点的本地事务必须成功，才能提交整个分布式事务。

### 9.2 两阶段提交协议（2PC）
#### 核心思想
发起计算的客户端作为协调器，需提交操作的进程作为参与者。协议分为两个阶段：

| 阶段 | 步骤 | 描述 |
| ---- | ---- | ---- |
| 准备阶段（Phase 1） | 1a：协调器发送VOTE-REQUEST（预写）给所有参与者 | 协调器请求参与者投票 |
|  | 1b：参与者收到VOTE-REQUEST后，返回VOTE-COMMIT或VOTE-ABORT | 参与者同意提交则返回VOTE-COMMIT，否则返回VOTE-ABORT并终止本地计算 |
| 提交阶段（Phase 2） | 2a：协调器收集所有投票，若全为VOTE-COMMIT则发送GLOBAL-COMMIT，否则发送GLOBAL-ABORT | 协调器根据投票结果做出全局决策 |
|  | 2b：参与者等待GLOBAL-COMMIT或GLOBAL-ABORT，并执行相应操作 | 参与者根据全局决策提交或终止本地事务 |

#### 有限状态机模型
- **协调器状态**：INIT（初始状态）→ WAIT（等待投票）→ COMMIT（全局提交）或ABORT（全局终止）。
- **参与者状态**：INIT（初始状态）→ READY（准备提交）→ COMMIT（提交）或ABORT（终止）。

#### 关键状态说明
- **INIT状态（参与者）**：等待协调器的VOTE-REQUEST消息，超时未收到则本地终止事务并发送VOTE-ABORT。
- **WAIT状态（协调器）**：等待所有参与者的投票，超时未收到所有投票则全局终止并发送GLOBAL-ABORT。
- **READY状态（参与者）**：等待协调器的全局决策，超时未收到则无法自行决策，需等待协调器恢复或询问其他参与者。

#### 故障处理
- **参与者故障**：
  - INIT状态：故障恢复后可安全终止事务并通知协调器。
  - READY状态：故障恢复后需知道协调器的决策，需记录协调器的决策或询问其他参与者。
  - COMMIT/ABORT状态：故障恢复后恢复到该状态并重新发送决策给协调器。
- **协调器故障**：
  - WAIT状态：故障恢复后需重新发送VOTE-REQUEST。
  - 决策状态：故障恢复后需重新发送全局决策。
- **参与者在READY状态的故障恢复**：参与者可联系其他参与者获取决策：
  - 若其他参与者处于COMMIT状态，则自身提交。
  - 若其他参与者处于ABORT状态，则自身终止。
  - 若其他参与者处于INIT状态，则自身终止。
  - 若其他参与者也处于READY状态，则协议阻塞，需等待协调器恢复。

## 10. 恢复
### 10.1 核心思想
故障发生后，将系统恢复到无错误状态，主要分为两种恢复方式：
- **前向错误恢复（Forward error recovery）**：找到系统可继续运行的新状态，需提前知晓可能的错误并进行纠正。
- **后向错误恢复（Backward error recovery）**：将系统恢复到之前的无错误状态，通过定期记录系统状态（检查点）实现。若发生故障，恢复到最近的检查点。

#### 示例
可靠通信中，数据包丢失时发送者重传，属于后向恢复（回到数据包发送前的状态）。

#### 后向恢复的缺点
- 性能开销：恢复过程可能耗费大量资源（如进程崩溃或站点故障的恢复）。
- 无故障避免保证：恢复后可能再次发生相同故障，需应用程序参与恢复。
- 不可逆状态：部分状态无法回滚（如ATM吐钞后，无法将已取出的现金放回）。

### 10.2 检查点（Checkpointing）
#### 核心要求
后向错误恢复需定期保存系统的一致全局状态（分布式快照）：若进程P记录收到某消息，则必须有进程Q记录发送该消息。

#### 恢复线（Recovery line）
指最新的一致全局快照，即最近的一组一致检查点。故障后，系统恢复到恢复线对应的状态。

#### 检查点的类型
- **协调式检查点（Coordinated Checkpointing）**：
  - 核心思想：所有进程同步保存状态到本地存储，确保保存的状态是全局一致的。
  - 简单实现（两阶段阻塞协议）：
    1. 协调器多播检查点请求消息。
    2. 参与者收到请求后，保存检查点，停止发送应用消息，并向协调器确认。
    3. 协调器收到所有确认后，广播检查点完成消息，允许进程继续运行。
  - 优化：仅向依赖协调器恢复的进程发送检查点请求（增量快照），减少开销。
- **独立式检查点（Independent Checkpointing）**：
  - 核心思想：每个进程独立保存本地状态，无需同步。
  - 缺点：可能导致级联回滚（Cascaded Rollback）。若各进程的检查点不一致，恢复时需不断回滚，甚至回到系统启动状态。
  - 依赖跟踪：进程发送消息时包含自身的检查点信息，接收者记录依赖关系，回滚时需根据依赖关系同步回滚。

### 10.3 消息日志（Message Logging）
#### 核心思想
不依赖昂贵的检查点，而是通过日志记录消息，从最近的检查点重放通信行为，恢复系统状态。

#### 假设条件（分段确定性执行模型）
- 每个进程的执行可分为一系列状态区间。
- 每个状态区间以非确定性事件（如消息接收）开始。
- 状态区间内的执行是确定性的。

#### 结论
记录非确定性事件（如消息接收），即可重放进程的执行，实现完全恢复。

#### 消息日志的时机
为避免孤儿进程（如进程Q接收并交付消息$m_1$和$m_2$后发送$m_3$给R，若$m_2$未日志化，Q恢复后无法重放$m_2$，导致R的$m_3$成为孤儿），需在消息交付前日志化消息。

#### 日志类型
- **发送方日志（Sender-Based Logging）**：进程保存检查点后，发送消息前日志化消息。
- **接收方日志（Receiver-Based Logging）**：接收进程接收消息后，交付给应用前日志化消息。

#### 优势
结合检查点和消息日志，可减少检查点的频率，降低性能开销，同时确保恢复的一致性。例如，故障后恢复到最近的检查点，并重放日志中的消息，恢复到故障前的状态。