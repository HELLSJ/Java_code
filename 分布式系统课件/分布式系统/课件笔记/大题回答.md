## Question 1
### 1. Purpose of Continuous Consistency  

**English Answer**: The core purpose of continuous consistency is to **allow controllable deviations (in numerical values, timeliness, or update order) between replicas**. It **reduces the high coordination costs of strong consistency** while **meeting the practical consistency requirements of applications**.  

**中文答案**：连续一致性（Continuous Consistency）的核心目的是允许副本之间在数值、时效性或更新顺序上存在可控偏差，从而降低强一致性带来的高昂协调成本，同时满足应用对一致性的实际需求。

### 2. Quantitative Observation Methods  

**English Answer**: Three key quantitative dimensions are used: 
① Numerical deviation，which refers to absolute/relative differences between replica values, e.g., stock price differences ≤ $0.02, if one replica updates immediately within these limits, the replicas are still considered consistent. 
② Staleness deviation, which refers to how old replica data is. Some applications can handle old data as long as it's not too old.  e.g., weather report validity ≤ 2 hours 
③ Order deviation: there may be differences regarding (number and order) of performed update operations. Some applications can tolerate different orderings of updates across replicas, as long as these differences are within certain bounds.

**中文答案**：量化观测主要通过三个维度实现：
① 数值偏差：副本间数据的绝对/相对差异，如股价差异≤0.02美元， 只要更新后副本仍在该范围内，即视为⼀致。
② 时效性偏差：副本数据的陈旧程度，部分应⽤可接受陈旧数据。如天气预报有效期≤2小时。
③ 顺序偏差：已执⾏的更新操作在（数量和顺序）⽅⾯可能存在差异。部分应⽤程序可以容忍不同副本间更新顺序的不⼀致，只要这些差异处于特定范围内。

### 3. 用户中心的一致性模型如何实现

**English Answer**

Client-centric consistency is implemented using **globally unique write identifiers** and two client-maintained sets: **a read set and a write set**.
Each **write** has a **unique ID**. The **read set records writes** already **read by the client**, and the **write set records the client’s own writes**. These sets are sent to the server with each request.
Based on this mechanism, the following consistency models are ensured
1. **Monotonic Reads:** The server ensures all writes in the read set are applied before serving a read.
2. **Monotonic Writes:** The server executes a client’s write operations **in order**.
3. **Read-Your-Writes:** The server executes all writes in the write set before a read.
4. **Writes-Follow-Reads:** The server synchronizes the read set before executing new writes.

**中文答案**：

**用户中心一致性通过全局唯一写操作标识符以及客户端维护的读集合和写集合来实现。**  
每个写操作都有唯一 ID，读集合记录客户端已读的写操作，写集合记录客户端自身的写操作，请求时一并发送给服务器。
基于这个机制，下面的一致性模型要被保证
1. **单调读**：服务器在读前同步读集合，保证不会读到旧数据。
2. **单调写**：服务器保证同一客户端的写操作按顺序执行。
3. **写后读**：服务器在读前执行写集合中的所有写操作。
4. **读后写**：服务器在写前同步读集合，保持因果关系。

### 4. 给出Replica Operation Ordering and Sequential Consistency的配置场景，分析replica按照某种给定的步骤执行各自操作，能否保证sequential consistency

**定义**：任何执行的结果，==**都等同于所有进程的操作按某种顺序依次执行的结果，且每个独立进程的操作，都按照其程序规定的顺序出现在该序列中。**==

**The result of any execution is the same as if the operations of all processes were executed in some sequential order**, and the operations of each individual process appear in this sequence in the order specified by its program.

这意味着数据存储的表现，就好像所有读写操作都按某个特定顺序发生一样。即便进程位于不同机器上，每个进程都会按照自身程序设定的序列看到这些操作。关键在于，所有进程都会以相同的顺序看待这些操作 —— 而这些操作**在实际时间中的发生顺序并不重要**。

It is when a data store behaves as if all read and write operations happened in a specific order. Each process sees these operations in the sequence set by its own program, even if they're on different machines. What's important here is that all processes view the operations in the same order, but **it doesn’t matter when they actually happened in real-time.**

**示例分析**：

- 符合顺序一致性的存储：进程$P1$先写$x$为$a$，进程$P2$后写$x$为$b$，进程$P3$和$P4$均先读取到$b$、后读取到$a$，所有进程感知的写操作顺序一致。
- 不符合顺序一致性的存储：$P3$感知到$x$先变为$b$再变为$a$，而$P4$先读取到$a$再读取到$b$，进程间操作顺序感知不一致，违反顺序一致性。
![[Pasted image 20251227162511.png]]

![[Pasted image 20251228140810.png]]
- **Prints**：按 print 实际发生的时间顺序 拼接
- **Signature**：按 固定进程顺序 `P1 → P2 → P3` 拼接

顺序一致性是一种至关重要的模型，因为在开发并发应用程序时它是最易于理解的。当多个程序同时处理共享数据时，它能够符合我们的预期。然而，实现这一型并非易事。

考虑两个变量x和 y。如果 P1从x中读取值为'a’，而 P2 从y中读取值为'b’，乍看之下似乎并无不妥。但在考虑每个过程的执行顺序时，却无法对x和y上的这些操作进行排序，以使两次读取结果保持一致。这意味着 P1和 P2 进行的操作之间难以匹配，表明顺序一致性在不同数据项之间并不总能良好结合。正如表格所示，操作存在**多种可能的排序方式，进而导致多种结果的产生。**

![[Pasted image 20251228142030.png]]

### 5. Implementation of Read-Your-Writes Consistency in Browser Caching  

**English Answer**:

Read-Your-Writes consistency in browser caching ensures that a client always reads its own latest updates.

- **Client write tracking**: The browser maintains a write set recording the client’s own write operations and sends it with each read request.
- **Server synchronization**: Before replying, the server checks whether all writes in the write set have been applied. If not, it fetches missing updates from other servers.
- **Web cache freshness control**: To prevent stale cached data from breaking consistency, two strategies are used:
	- **Active validity verification (Option 1)**: The cache contacts the origin server to confirm if the cached content is still up-to-date
	- **Expiration time-based validity (Option 2)**: **Use expiration-based validity**, where cached documents are considered valid until an expiration time computed from the last modification time.

The specific process is:
  1. When the cache stores a document, it records **two timestamps**: $T_{last\_modified}$ (the document’s last modification time, provided by the origin server) and $T_{cached}$ (the time when the document is cached locally).
  2. Calculate the expiration time using the formula: $$T_{expire} = \alpha(T_{cached} - T_{last\_modified}) + T_{cached}$$
	  - (where $\alpha = 0.2$ as a typical coefficient).
  3. Before responding to a client’s read request, the cache checks if the current time is earlier than $T_{expire}$:
	 - If yes: The cached content is considered valid, and the cache returns it directly.
	 - If no: The cached content is marked as stale, and the cache initiates a fresh request to the origin server to get the latest content (updating the cache and $T_{expire}$ afterward).

**中文答案**：

浏览器缓存中的**写后读一致性（Read-Your-Writes）** 保证客户端总能读到自己最近写入的数据。

1. **客户端写集合维护**：浏览器维护写集合，记录客户端自身的写操作，并在读请求时发送给服务器。
2. **服务器同步检查**：服务器在返回数据前，确认已执行写集合中的所有写操作，若未完成则先同步更新。
3. **保障缓存新鲜度**：为避免陈旧缓存数据破坏一致性，采用两种策略：
   - **主动验证有效性（方案1）**：缓存向源服务器确认缓存内容是否仍为最新版本，再返回给客户端。
   - **基于过期时间的有效性（方案2）**：具体流程为：
	  1. 当缓存存储文档时，记录两个时间戳：$T_{last\_modified}$（文档的最后修改时间，由源服务器提供）和 $T_{cached}$（文档被本地缓存的时间）。
	  2. 通过公式计算过期时间：$T_{expire} = \alpha(T_{cached} - T_{last\_modified}) + T_{cached}$（其中 $\alpha$ 通常取0.2）。
	  3. 在响应客户端的读取请求前，缓存检查当前时间是否早于 $T_{expire}$：
	     - 若是：缓存内容被判定为有效，直接返回给客户端。
	     - 若否：缓存内容被标记为陈旧，缓存向源服务器发起新请求以获取最新内容（之后更新缓存及对应的 $T_{expire}$）。
![[Pasted image 20251228235022.png]]
![[Pasted image 20251228235052.png]]
![[Pasted image 20251228235112.png]]
## Question 2
### 1. Stateless application relying on replication to tolerate faults的场景下，replica可能有故障、可能有延迟、可能无法发送响应给主节点等情况，需要多少replica能容纳k个错误

**English Answer**:
In stateless applications (which have no persistent state and only need correct request handling), to tolerate k errors (e.g., replica crashes, latency, failure to respond to the primary), **at least k+1 replicas are required**.

Reason: Stateless applications do not rely on state synchronization, so any functional replica can independently process requests correctly. When k replicas fail (or are delayed/unresponsive), the remaining 1 normal replica can still handle requests, ensuring service continuity.

**中文答案**：
在无状态应用（无持久化状态，仅需正确处理请求）场景下，要容纳 k 个错误（如副本故障、延迟、无法向主节点发送响应），**至少需要 k+1 个副本**。

原因：无状态应用无需依赖状态同步，任意可用的副本都能独立正确处理请求。当 k 个副本出现错误（故障/延迟/无响应）时，剩余1个正常副本仍可处理请求，保障服务持续可用。

![[Pasted image 20251228195102.png]]
### 2. 如果有replica被compromised（副本被攻破 / 沦陷），需要多少replica实现拜占庭容错？

**English Answer**: 
To tolerate k compromised (Byzantine) replicas, **at least 3k+1 replicas are required** (instead of 2k+1 for non-Byzantine faults).

The key reason is that Byzantine replicas can exhibit "dishonest" behavior: they may send conflicting messages to different honest replicas (e.g., a malicious replica sends value X to one honest node and Y to another). This leads to honest nodes perceiving different "majority" results, causing system divergence.

When the total replica count is 3k+1:
- The number of honest replicas is 3k+1 - k = 2k+1.
- To reach consensus, a majority (≥ 2k+1 replicas) is required (since 2k+1 > (3k+1)/2, satisfying the majority condition).
- Any two such majorities will intersect by at least (2k+1) + (2k+1) - (3k+1) = k+1 nodes. Since there are only k malicious replicas, this intersection must include at least 1 honest node—ensuring honest replicas can align on a consistent result and avoid divergence.

**中文答案**：

要容忍 k 个被攻破的（拜占庭）副本，**至少需要 3k+1 个副本**（区别于非拜占庭故障的 2k+1 个副本）。
核心原因是拜占庭副本会表现出“不诚实”行为：它们可能向不同诚实副本发送矛盾消息（例如，恶意副本向一个诚实节点发值X，向另一个发值Y），导致诚实节点感知到不同的“多数派”结果，进而引发系统分叉。

当总副本数为 3k+1 时：
- 诚实副本数为 3k+1 - k = 2k+1；
- 共识需满足多数派条件（≥ 2k+1个副本），而 2k+1 > (3k+1)/2，符合多数派的数学要求；
- 任意两个这样的多数派交集至少包含  (2k+1)+(2k+1)-(3k+1) = k+1  个节点。由于恶意副本仅 \(k\) 个，该交集必然包含至少1个诚实节点——确保诚实副本能对齐一致结果，避免系统分叉。

### 3. 如果availability比consistency重要，根据CAP理论，系统在出现partition时应如何运行保证availability?（仔细看看容错理论、Paxos等知识）

**English Answer**: According to the CAP theory, when network partition (P) occurs and availability (A) is prioritized over consistency (C), the system should: ① Allow each partition to continue independent operations (e.g., processing local reads/writes) instead of blocking; ② Use eventual consistency protocols (e.g., Paxos with leader election in each partition) to sync data after the partition heals; ③ Disable Strict Consensus: The system must abandon protocols like Paxos or Raft that require a majority quorum because nodes in a minority partition would otherwise become unavailable. ④ Return Best-Available Data: To ensure availability, nodes should return their locally stored data to the client, even if it might be stale (not the most recent version).

**中文答案**：根据CAP理论，当出现网络分区（P）且可用性（A）优先于一致性（C）时，系统应：① 允许每个分区独立运行（如处理本地读写操作），而非阻塞；② 采用最终一致性协议，在分区恢复后同步数据；③ 禁用严格共识机制：系统要放弃诸如 Paxos或 Raft 这样的协议，这些协议要求达到多数同意阈值，因为若采用此类协议，处于少数分区中的节点便无法被正常使用；④ 返回最佳可用数据：为确保可用性，节点应将本地存储的数据返回给客户端，即使这些数据可能已过时(非最新版本).
