## 目录

- 架构风格
    - 分层架构
    - 面向服务架构
    - 发布 - 订阅架构
- 中间件
- 分层系统架构
    - 简单客户端 - 服务器架构
    - 多层架构
- 对称分布式系统架构
    - 结构化对等网络（P2P）系统
    - 非结构化对等网络（P2P）系统
    - 分层组织的对等网络（P2P）
- 混合系统架构
    - 云计算
    - 边缘 - 云架构
    - 区块链架构

---

## 架构风格

### 核心思想

架构风格通过以下要素定义：

- 具有明确定义接口的（可替换）组件
- 组件之间的连接方式
- 组件之间交换的数据
- 这些组件和连接器如何共同配置为一个系统

组件是具有明确定义的需求接口和提供接口的模块化单元，设计目的是在其环境中可替换。无需中断系统运行即可替换组件至关重要 —— 通常系统无法为维护而停机，只能将部分组件临时下线。只有组件接口保持不变，替换才可行。实际应用中，服务器或系统部分会定期更新，安装完成后切换到更新后的组件；若更新需重启系统部分，可通过特殊措施确保重启期间的连续性。

### 连接器

用于协调组件之间通信、协作的机制，例如（远程）过程调用、消息传递或流传输工具。连接器支持组件之间的控制流和数据流传输，结合组件和连接器可构建多种配置，这些配置被归类为不同的架构风格。

### 关键风格

- 分层架构（Layered architectures）
- 面向服务架构（Service-oriented architectures）
- 发布 - 订阅架构（Publish-subscribe architectures）

## 分层架构

### 不同的分层组织形式

分层风格的核心思想简单：组件按层组织，第 Lj 层的组件可向下调用第 Li 层（i < j）的组件，且通常期望获得响应，仅在特殊情况下才会向上调用更高层组件。

#### （a）纯分层组织

仅允许向下调用相邻的下一层组件，是标准的分层形式。
![[Pasted image 20251112155819.png]]
#### （b）混合分层组织

按层级结构组织，每一层为直接上层提供服务，同时作为直接下层的客户端。例如：

- 顶层（N-1 层）：核心应用程序（Application A），直接与用户或其他系统交互。
- 中间层（N-2 层）：数学库（L_math），为应用程序 A 提供专业的数学功能。
- 底层（N-3 层）：操作系统接口库（L_os），作为操作系统的接口，为数学库及其他潜在应用提供基础服务。
    
应用程序 A 使用 L_math 的特定功能，L_math 则依赖 L_os 进行底层系统交互，L_os 是两者共用的基础层，封装了操作系统交互的复杂性。
![[Pasted image 20251112155828.png]]
#### （c）带向上调用的分层组织

允许下层组件向上调用相邻的上层组件，这种设计很实用。例如，操作系统完成 I/O 中断后，需要通知应用程序处理（如从缓冲区读取数据），此时会触发向上调用。
![[Pasted image 20251112155837.png]]
### 示例：通信协议

通信协议栈是分层架构的典型应用，每一层实现一项或多项通信服务，支持数据从一个节点传输到一个或多个目标节点。

- 接口：每一层提供明确的可调用函数规范。
- 协议：描述通信双方需遵循的规则（如互联网中的传输控制协议 TCP），包括连接建立 / 断开时的消息交换规则、数据传输顺序保持机制、数据丢失检测与纠正方法等。
![[Pasted image 20251112155902.png]]
#### 代码示例：基于 Socket 的双方通信

**服务器端代码**：

```python
from socket import *
s = socket(AF_INET, SOCK_STREAM)
(conn, addr) = s.accept()  # 返回新的套接字和客户端地址
while True:  # 持续运行
    data = conn.recv(1024)  # 从客户端接收数据
    if not data:
        break  # 客户端停止则退出
    msg = data.decode()  # 处理输入数据并生成响应
    conn.send(msg.encode())  # 返回响应
conn.close()  # 关闭连接
```

**客户端代码**：

```python
from socket import *
s = socket(AF_INET, SOCK_STREAM)
s.connect((HOST, PORT))  # 连接服务器（阻塞直到接受）
msg = "Hello World"  # 构建消息
s.send(msg.encode())  # 发送消息
data = s.recv(1024)  # 接收响应
print(data.decode())  # 打印结果
s.close()  # 关闭连接
```

常量`AF_INET`和`SOCK_STREAM`指定通信使用 TCP 协议，这两个常量属于接口的一部分，而 TCP 的使用则是提供的服务内容。
![[Pasted image 20251112155930.png]]
### 应用分层

#### 传统三层视图

- 应用接口层：包含与用户或外部应用交互的单元。
- 处理层：包含应用的核心功能（不含特定数据）。
- 数据层：包含客户端通过应用组件想要操作的数据。

这种分层广泛应用于采用传统数据库技术及相关应用的分布式信息系统中。

#### 示例：简单搜索引擎

以房屋购买专用搜索引擎为例：

- 接口层：用户通过网站输入城市、价格范围、房屋类型等描述信息。
- 处理层：将用户描述转换为数据库查询语句，获取结果后进行相关性排序等后处理，生成 HTML 页面。
- 数据层：存储待售房屋信息的大型数据库。
![[Pasted image 20251112155943.png]]
### 分层架构的缺点

尽管分层架构应用广泛，但存在显著缺点，其中最主要的是不同层之间的强依赖性。

- 正面示例：通信协议栈的设计中，层间依赖得到了精心管理。
- 负面示例：部分应用使用现有组件拼凑而成，未关注接口或组件本身的稳定性，甚至不同组件间存在功能重叠，导致层间依赖混乱。

这种对特定组件的直接依赖，催生了一种更松散的架构风格 —— 将系统组织为多个独立的实体集合，每个实体提供一项服务（这些实体可称为服务、对象或微服务），均以独立进程或线程的形式运行。需注意，与分层架构相比，运行这些独立实体并不一定能减少依赖。

## 面向服务架构（SOA）

### 定义

面向服务架构（SOA）是一种设计模式，用于构建通过协议向其他应用提供服务的分布式系统，不受编程语言或平台限制。
### 服务的定义

服务是具有明确定义、独立完整的功能单元，可与其他服务交换信息，不依赖其他服务的状态，采用松耦合、基于消息的通信模型与应用程序及其他服务交互。

### 核心原则

- 松耦合：用于满足可扩展性、灵活性和容错性需求，旨在最小化依赖关系。依赖越少，一个系统的修改或故障对其他系统的影响就越小。
- 可重用性：服务设计为可在不同场景中重用，提升系统效率和一致性。
- 自主性：服务独立运行，自主控制自身功能。

### 服务连接

服务消费者向服务提供者发送服务请求，服务提供者向消费者返回服务响应，服务连接需同时被双方理解。

### 关键术语

- 服务提供者：实现服务规范的软件实体。
- 服务消费者：调用服务提供者的请求方或客户端，可为其他服务或终端用户应用。
- 服务定位器：作为注册中心的服务提供者，负责检查服务提供者接口和服务位置。
- 服务代理：将服务请求转发给一个或多个其他服务提供者的服务提供者。
![[Pasted image 20251112160028.png]]
### 组件构成

![[Pasted image 20251112160045.png]]
#### 功能层面

- 传输层：将服务请求从消费者传输到提供者，将服务响应从提供者传输到消费者。
- 服务通信协议：支持服务提供者和消费者之间的通信。
- 服务描述：描述服务及调用所需的数据。
- 服务：实际提供的功能单元。
- 业务流程：按特定顺序调用一组服务，并遵循特定规则，以满足业务需求。
- 服务注册中心：存储服务提供者发布服务所需的描述数据。

#### 服务质量层面

- 策略：服务提供者向消费者提供服务时遵循的一组协议。
- 安全性：用于身份识别和授权的一组协议。
- 事务：确保结果一致性，即一组服务共同完成业务功能时，要么全部执行成功，要么全部不执行。
- 管理：定义用于管理服务的一组属性。

### 通信方式

- 服务通过 HTTP、REST 或 SOAP 等标准协议通信
- 消息通常采用 XML 或 JSON 格式
- 支持同步（请求 / 响应模型）和异步（消息队列）两种通信模式。

### 优势

- **可扩展性**：服务可独立扩展，资源利用更高效。
- **灵活性**：便于更新和修改系统部分，不影响其他组件。
- **互操作性**：基于标准协议，可跨不同技术和平台运行。

### 挑战

- 复杂性：管理服务之间的交互和集成较为复杂。
- 性能：网络延迟和消息处理可能影响系统性能。
- 安全性：网络暴露服务增加了安全威胁风险。

### 应用案例：银行系统集成

银行通常运行多种应用系统，处理贷款、支票账户、储蓄账户、投资等不同金融产品和服务，通过 SOA 可实现这些系统的高效集成。

### 相关架构风格

#### 基于对象的架构风格

核心：组件为对象，通过过程调用连接。对象可部署在不同机器上，调用可跨网络执行。

- 封装性：对象封装数据，并提供操作数据的方法，不暴露内部实现。
- 优势：在分布式系统中，基于对象的方法可灵活封装组件，便于跨机器无缝处理数据和操作。
![[Pasted image 20251112160217.png]]
#### 基于资源的架构风格（表述性状态转移 Representational State Transfer，REST）

核心：将分布式系统视为资源集合，资源由组件单独管理，远程应用可对资源执行添加、删除、查询和修改操作。

- 核心特征：
    1. 资源通过统一命名方案标识。
    2. 所有服务提供相同的接口。
    3. 发送到服务或从服务接收的消息完全自描述。
    4. 服务执行操作后，不保留任何关于调用者的信息。
![[Pasted image 20251112160231.png]]

#### 示例：亚马逊简单存储服务（Amazon S3）

- 核心逻辑：文件（对象）存储在存储桶（目录）中，存储桶不能嵌套。操作存储桶`BucketName`中名为`ObjectName`的对象需使用统一资源标识符（URI）：`http://BucketName.s3.amazonaws.com/ObjectName`。
- 典型操作（通过 HTTP 请求执行）：
    1. 创建存储桶 / 对象：使用 PUT 请求，若存储桶 / 对象已存在，返回 HTTP 错误信息。
    2. 列出对象：对存储桶名称发送 GET 请求，获取存储桶中的对象列表。
    3. 读取对象：对完整 URI 发送 GET 请求。

#### REST 架构的优缺点

- 优点：简洁易用，使用 GET、PUT、POST、DELETE 等标准 HTTP 请求，易于理解。
- 缺点：在需要复杂通信方案（如分布式事务）的场景中存在局限性，因 REST 服务执行操作后不保留状态。
- 适用场景：适用于无需大量服务特定接口的场景，为服务提供简单的集成方案，在许多基于 Web 的分布式系统中应用广泛。

## 发布 - 订阅架构

### 协调机制

随着系统规模扩大和动态性增强（进程可轻松加入或退出），需要一种进程间松依赖的架构。许多分布式系统采用 “处理与协调分离” 的方法：系统由一组独立运行的进程组成，协调负责进程间的通信和协作，是连接所有进程的 “胶水”。

### 两种协调模型：时间耦合与引用耦合

|      | 时间耦合    | 时间解耦     |
| ---- | ------- | -------- |
| 引用耦合 | 直接协调    | 邮箱协调     |
| 引用解耦 | 基于事件的协调 | 共享数据空间协调 |

- 直接协调（时间耦合 + 引用耦合）：进程需相互知晓且同时活跃，例如打电话（需知道对方号码，且对方需接听）。
- 邮箱协调（时间解耦 + 引用耦合）：进程无需同时活跃，可将消息放入邮箱，但需知道邮箱位置。
- 基于事件的协调（时间耦合 + 引用解耦）：进程不直接知晓彼此，仅发布事件通知，其他进程可订阅。理想情况下，通知仅发送给订阅者，但订阅者需在通知发送时处于活跃状态。
- 共享数据空间协调（时间解耦 + 引用解耦）：进程通过元组（类似数据库行的结构化数据记录）通信，可向共享数据空间写入元组或通过搜索模式检索元组，支持关联搜索（指定感兴趣字段的值，返回匹配元组）。

### 发布 - 订阅架构的组合形式

共享数据空间常与基于事件的协调结合：进程通过提供搜索模式订阅特定元组，当新的匹配元组被添加时，订阅者会收到通知。这种架构中，进程不直接知晓彼此，属于典型的发布 - 订阅架构。
![[Pasted image 20251112160402.png]]
### 示例：Linda 元组空间

#### 三个核心操作

- `in(t)`：移除与模板`t`匹配的元组。
- `rd(t)`：获取与模板`t`匹配的元组副本。
- `out(t)`：向元组空间添加元组`t`。

#### 补充说明

- 连续调用两次`out(t)`会存储两个元组`t`副本，元组空间被建模为多重集合。
- `in`和`rd`均为阻塞操作：调用者会被阻塞，直到找到匹配元组或元组可用。

#### 应用场景

元组格式为`<string, string, string>`，分别表示发布者名称、主题和消息内容。例如，共享数据空间 “MicroBlog” 中：

- Bob 发布三条消息：两条主题为 “分布式系统（distsys）”，一条主题为 “全球电信网络（gtcn）”。
- Alice 发布两条消息：分别对应上述两个主题。
- Chuck 读取三条消息：Bob 的一条 “distsys” 消息、Bob 的一条 “gtcn” 消息、Alice 的一条 “gtcn” 消息。
    
    发布者（Alice、Bob）无需知道谁会读取消息，实现了松耦合。

### 关键问题：事件匹配

发布 - 订阅系统的核心是基于订阅者感兴趣的事件进行通信，事件通过（属性，值）对描述。发布事件通知后，订阅者需向中间件发送包含感兴趣事件描述的订阅请求，事件匹配主要有两种方式：

- 基于主题的订阅：指定 “属性 = 值” 序列（如 “主题 = 分布式系统”）。
- 基于内容的订阅：指定 “属性∈范围” 序列（如 “价格∈[100, 200]”）。

描述越详细，事件匹配难度越大。

### 通知与数据传输

找到匹配的订阅后，中间件有两种处理方式：

1. 将通知和相关数据一起转发给所有匹配的订阅者，此时中间件通常不存储数据。
2. 仅发送通知，订阅者收到通知后执行读取操作获取数据，此时中间件需存储数据，涉及额外的数据管理操作。

### 事件组合与可扩展性挑战

- 事件组合问题：部分订阅需要组合多个原始事件（如 “房间 1 无人且门未锁时通知”），需将来自分布式系统不同部分的原始事件（如占用传感器、门锁传感器数据）组合为可订阅的数据项，这一过程具有挑战性。
- 基于内容的订阅的可扩展性问题：详细且多样的订阅与传入通知的匹配过程会导致严重的性能瓶颈，随着系统规模扩大，匹配的计算负载和资源需求呈指数增长，同时还需考虑安全性和隐私性，实际实现中常面临严重的可扩展性问题。

## 中间件：分布式系统的操作系统

### 核心定位

在网络中计算机的操作系统之上，通过独立的软件层构建分布式应用、组织分布式系统，该软件层即为中间件。例如，4 台联网计算机和 3 个应用程序（如应用 B 跨计算机 2 和 3 运行），中间件为每个应用提供统一接口，支持单个分布式应用的组件间通信、不同应用间通信，并尽可能向应用隐藏硬件和操作系统的差异。

### 核心功能

- 资源管理：支持应用程序通过网络高效共享和使用资源。
- 提供的服务：
    1. 应用间通信工具。
    2. 安全服务。
    3. 计费服务。
    4. 故障屏蔽与恢复。
- 核心特点：中间件服务运行在网络环境中，为多个应用提供通用功能，避免应用重复实现这些功能。

### 中间件的构建：基于遗留系统

#### 问题

遗留组件提供的接口可能不适用于所有应用程序。

#### 解决方案：包装器（Wrapper）或适配器（Adapter）

- 功能：提供客户端应用可接受的接口，将遗留组件的功能转换为应用可用的形式，解决接口不兼容问题。
- 扩展应用：在分布式系统中，包装器不仅是简单的接口转换器。例如，对象适配器允许应用调用远程对象，即使这些对象只是操作数据库表的库函数集合。
- 示例：亚马逊 S3 存储服务提供两种接口（RESTful 架构接口和传统接口），RESTful 接口的客户端通过 HTTP 协议与传统 Web 服务器通信，该服务器作为适配器连接实际的存储服务，处理请求并将其传递给 S3 中的专用服务器。

#### 中间件的组织形式

1. 一对一模式：应用 A 需从应用 B 获取数据时，为 B 创建专用包装器。缺点：扩展性差，N 个应用需 N×(N-1)=O (N²) 个包装器。
2. 基于代理（Broker）的模式：通过集中式代理组件管理所有应用间的交互（如消息代理）。应用向代理发送包含需求的请求，代理联系相关应用，组合并转换响应后返回给请求应用。优点：扩展性好，N 个应用仅需 2N=O (N) 个包装器。

### 拦截器（Interceptors）：控制流管理

#### 核心功能

拦截正常的控制流，允许执行其他代码，是中间件适应应用特定需求的关键，增强了中间件的开放性和灵活性。

#### 权衡与考量

- 实现通用拦截器需投入大量精力，需平衡灵活性和简洁性。
- 有限的拦截能力可降低软件和分布式系统的管理复杂度。

#### 示例：远程对象调用

对象 A 调用远程对象 B 的方法，过程分为三步：

1. 对象 A 拥有与对象 B 相同的本地接口，通过该接口调用方法。
2. 借助 A 所在机器上中间件提供的通用对象调用接口，将该调用转换为通用对象调用（如`invoke(B, &doit, val)`）。
3. 将通用调用转换为消息，通过 A 的本地操作系统的传输层接口发送到网络。

#### 拦截器的具体应用

- 请求级拦截器：若对象 B 被复制，请求级拦截器会为每个副本调用`invoke(B, &doit, val)`，对象 A 和中间件无需知晓 B 的复制情况，仅拦截器需了解。
- 消息级拦截器：若参数`val`是大型数据数组，消息级拦截器可将其分割为小块，在目的地重组，提升性能或可靠性，中间件无需干预，由底层拦截器处理与本地操作系统的通信。

---

## 分层系统架构

### 客户端 - 服务器架构

#### 核心特征

- 分布式系统中的进程分为两组（有时重叠）：服务器提供特定服务（如文件系统服务、数据库服务），客户端通过发送请求并等待响应的方式向服务器请求服务，这种交互模式称为请求 - 响应行为。
- 通信协议选择：
    1. 无连接协议：适用于局域网等可靠性较高的网络，高效但难以处理传输故障。客户端未收到响应时可能重发请求，但无法区分是原始请求丢失还是响应丢失。若操作是 “转账 10000 美元”，重发会导致重复执行；若操作是 “查询账户余额”，重发无影响，无通用解决方案。
    2. 面向连接的可靠协议：适用于广域网等可靠性较低的网络，多数互联网应用协议使用 TCP/IP。客户端先与服务器建立连接，发送请求后服务器通过同一连接返回响应，随后关闭连接。缺点：连接建立和关闭成本高，尤其适用于小型请求和响应场景。

#### 优点与缺点

- 优点：只要消息不丢失或损坏，请求 / 响应模式效率高。
- 缺点：难以处理偶尔的传输故障，客户端重发请求可能导致操作重复执行。

#### 解决方案：TCP 三次握手

TCP 通过 “带重传的肯定确认（PAR）” 实现可靠通信，传输层的协议数据单元称为段（segment）。发送方会重发数据单元直到收到确认，接收方收到损坏的段会丢弃，发送方需为重传未收到确认的数据单元。

##### 三次握手步骤

1. 同步（SYN）：客户端向服务器发送包含同步序列号（SYN）的段，告知服务器即将开始通信及起始序列号（如 seq=x）。
2. 同步 + 确认（SYN+ACK）：服务器响应 SYN-ACK 段，确认收到客户端的段（ACK=x+1），并告知客户端自己的起始序列号（如 seq=y）。
3. 确认（ACK）：客户端确认服务器的响应（ACK=y+1），双方建立可靠连接，开始实际数据传输。

### 多层系统架构

#### 传统组织形式

- 单层架构：哑终端 / 大型机配置，服务器承担大部分工作。
- 两层架构：客户端 / 单一服务器配置。
- 三层架构：每一层部署在独立机器上。

#### 传统两层架构的常见配置

分布式应用通常分为接口层、处理层和数据层，客户端和服务器的配置方式如下：

1. 配置（a）：客户端仅部署与终端相关的接口部分，其余功能由服务器处理。
2. 配置（b）：客户端部署完整的用户界面软件，通过特定协议与服务器上的应用程序其余部分通信，客户端仅负责接口展示，不参与处理。
3. 配置（c）：将部分应用程序迁移到前端，适用于需先填写表单再处理的场景（前端可验证表单正确性和一致性），或文字处理器（客户端处理基本编辑，服务器处理拼写检查等高级功能）。
4. 配置（d）：客户端为连接到分布式文件系统或数据库的个人计算机 / 工作站，大部分应用程序在客户端运行，文件和数据库操作由服务器处理（如银行应用在用户机器上准备交易，完成后上传到银行数据库服务器处理）。
5. 配置（e）：客户端本地磁盘存储部分数据（如浏览器缓存最近浏览的网页）。

#### 三层架构：同时作为客户端和服务器

在三层架构中，服务器可能同时扮演客户端角色。例如：

- 事务处理：处理层的程序通常运行在独立服务器上，由事务处理监视器协调跨多个数据服务器的事务。
- 网站架构：Web 服务器作为入口，将请求传递给应用服务器进行实际处理，应用服务器再与数据库服务器交互。

### 示例：网络文件系统（NFS）

#### 核心基础

每个 NFS 服务器提供统一的本地文件系统视图，无论文件系统的具体实现如何。NFS 使用特定通信协议，允许客户端访问服务器上的文件，支持运行在不同操作系统和机器上的各类进程共享文件系统。

#### 两种访问模型

1. 远程访问模型：客户端请求访问服务器上的远程文件，文件始终存储在服务器上，客户端通过接口（类似本地文件系统接口）执行文件操作，实际操作由服务器完成，客户端无需知晓文件实际位置。
2. 上传 / 下载模型：客户端从服务器下载文件，本地处理后再上传回服务器（如互联网 FTP 服务、Dropbox），其他客户端可后续使用该文件。

#### 现代 Unix 系统中的 NFS 架构

- 客户端：通过本地操作系统提供的系统调用访问文件系统，系统调用先传递到虚拟文件系统（VFS）层（不同分布式文件系统的标准接口），VFS 层将操作转发到本地文件系统或 NFS 客户端，NFS 客户端通过远程过程调用（RPC）将操作发送到服务器。
- 服务器：NFS 服务器接收客户端请求，RPC 组件将请求转换为标准 VFS 文件操作，传递给 VFS 层，VFS 层调用本地文件系统存储实际文件。
- 优势：NFS 基本独立于本地文件系统，客户端和服务器可使用不同的文件系统（如 Unix、Windows），只需符合 NFS 文件系统模型。

### 示例：Web 服务器

#### 简单 Web 服务器

- 网站由一组 HTML 文件组成，文件间通过超链接关联。
- Web 服务器仅需通过超链接获取文件，浏览器负责正确渲染文件内容。
- 交互流程：浏览器发送 HTTP 请求获取文档，服务器从本地文件系统读取文档并返回响应。

#### 复杂 Web 服务器（基于数据库）

- 网站围绕存储内容的数据库构建，网页仍可通过超链接访问。
- 交互流程：浏览器发送 HTTP 请求，Web 服务器启动公共网关接口（CGI）程序，CGI 程序与数据库服务器交互，创建 HTML 文档并返回给 Web 服务器，Web 服务器将文档作为响应返回给浏览器。

---

## 其他组织形式

### 垂直分布与水平分布

- 垂直分布：将分布式应用分为三个逻辑层，每个层的组件运行在不同服务器上。
- 水平分布：客户端或服务器在物理上拆分为逻辑等效的部分，每个部分处理完整数据集的子集。

### 对等网络（P2P）架构

- 核心特征：所有进程地位平等，均需执行相同功能，同时扮演客户端和服务器角色（即 “服务者”）。

---

## 结构化对等网络（P2P）系统

### 核心本质

使用无语义索引：每个数据项与唯一密钥关联，密钥作为索引（通常通过哈希函数生成：`key(数据项)=hash(数据项的值)`）。P2P 系统负责存储（密钥，值）对。

### 分布式哈希表（DHT）

系统存储（密钥，值）对，每个节点分配一个来自所有可能哈希值集合的标识符，负责存储与特定密钥子集相关的数据。结构化 P2P 系统的核心任务是通过密钥查找数据项，高效将密钥映射到存储对应数据的节点，系统的结构化拓扑至关重要 —— 任何节点均可接收密钥查找请求，并将请求路由到负责该密钥的节点。

### 示例 1：超立方体拓扑

超立方体为 n 维立方体，以 4 维超立方体（16 个节点，标识符 0000-1111）为例：

- 数据项的密钥通过哈希生成，范围为 0-15，对应 16 个节点。
- 查找过程：若节点 0111 需查找密钥 14（二进制 1110）对应的数据，可将请求转发给更接近 1110 的邻居（如 0110 或 1111），最终由节点 1110 返回数据。

### 示例 2：Chord 协议

#### 核心原则

- 节点逻辑上组织为环形，每个节点有 m 位标识符，数据项哈希为 m 位密钥。
- 密钥 k 对应的数据项存储在标识符最小且≥k 的节点（称为 k 的后继节点）。
- 环形扩展有多个指向其他节点的快捷链接，密钥和标识符通常为 128 位或 160 位。

#### 查找过程

以 m=5 位、9 个节点（1,4,9,11,14,18,20,21,28）的 Chord 环为例：

- 节点 9 需查找密钥 3 对应的节点（节点 4），通过快捷链接将请求转发给 28，28 转发给 1，1 的后继节点为 4，最终找到目标节点。

#### 节点加入与退出

- 加入：新节点 u 联系任意节点查找自身标识符的后继节点 v，插入到 v 的前驱节点和 v 之间，建立快捷链接，转移相关数据项。
- 退出：节点告知前驱和后继节点，将数据项转移给后继节点，更新相关快捷链接。

---

## 非结构化对等网络（P2P）系统

### 核心本质

每个节点维护临时的邻居列表，形成的覆盖网络类似随机图（边 <u,v> 的存在具有一定概率 P [<u,v>]）。

### 搜索机制

1. 泛洪（Flooding）：发起节点 u 将请求发送给所有邻居，接收节点若已处理过该请求则忽略，否则本地搜索数据并递归转发，可通过生存时间（TTL，最大跳数）限制转发范围。
2. 随机游走（Random Walk）：发起节点 u 将请求发送给随机选择的邻居 v，若 v 无目标数据，转发给其随机选择的邻居，依此类推。

### 性能模型

假设系统有 N 个节点，每个数据项复制到 r 个随机选择的节点：

- 随机游走：P [k] 为 k 次尝试后找到数据项的概率，S（“搜索规模”）为需要探测的平均节点数。
- 泛洪：k 步后可到达的节点数 R (k)=d・(d-1)^(k-1)（d 为每个节点的邻居数，k 较小时）。若 r/N 为拥有数据项的节点比例，当 r/N・R (k)≥1 时，可找到数据项。

### 两种搜索机制的对比

以 r/N=0.001（S≈1000）、d=10 为例：

- 泛洪：k=4 时，需联系 7290 个节点，通信开销大但速度快。
- 随机游走：通信效率高，但找到结果的时间可能更长。

---

## 分层组织的对等网络（P2P）

### 核心本质

打破纯对等网络的对称性，引入特殊节点（超级节点，Super peers）提升性能：

- 超级节点维护索引或充当代理，收集资源使用和可用性数据，可快速找到资源充足的节点。
- 超级节点自身组织为对等网络，形成分层结构，普通节点（弱节点，Weak peers）连接到超级节点，所有通信通过超级节点进行。

### 弱节点与超级节点的关联

- 常规模式：弱节点加入网络后连接到一个超级节点，直到退出，超级节点需保持稳定和高可用性（可通过备份机制，如超级节点配对、弱节点双连接实现）。
- 动态调整：在文件共享网络中，弱节点可切换到拥有自身感兴趣文件索引的超级节点，成功提供查找服务的超级节点会获得优先连接权。

### 示例：BitTorrent

#### 核心原则（查找文件 F）

1. 在全局目录中查找文件，获取种子文件（torrent file）。
2. 种子文件包含跟踪器（tracker）的引用，跟踪器是记录拥有文件 F 片段的活跃节点列表的服务器。
3. 节点加入节点群（swarm），免费获取一个文件片段，之后通过与其他节点交换片段获取完整文件。

#### 工作机制

- 协作激励：BitTorrent 鼓励用户共享，仅允许下载文件的用户同时上传文件。若节点 P 发现节点 Q 下载量远大于上传量，会降低向 Q 发送数据的速率。
- 节点关联：节点通常会获取多个其他节点的引用，以提高数据交换机会。

#### 集中式与去中心化结合

- 传统模式：跟踪器是系统瓶颈。
- 优化模式：节点加入独立的结构化 P2P 系统分担跟踪负载，每个节点为少量种子文件提供跟踪服务，原始跟踪器仅提供初始节点列表，后续节点直接通信。

---

## 混合系统架构

### 云计算

#### 核心本质

现实世界的分布式系统复杂，常混合多种架构（集中式、对等网络、分层组织），且跨多个组织，形成无单一管理方的去中心化解决方案。云计算的核心是提供易于使用、可访问的虚拟化资源池，支持动态配置资源，按需扩展，采用按使用付费模式，通常通过定制化服务级别协议（SLA）保证性能。

#### 四层架构

1. 硬件层：处理器、路由器、电源和冷却系统，用户通常无法直接接触。
2. 基础设施层：采用虚拟化技术，负责虚拟存储设备和虚拟服务器的分配与管理。
3. 平台层：提供更高层次的存储等抽象服务（如亚马逊 S3 存储系统，通过 API 将本地文件组织存储在 “存储桶” 中）。
4. 应用层：实际应用程序（如办公套件：文字处理器、电子表格、演示软件），类似操作系统预装的应用集合。

#### 服务类型

- 基础设施即服务（IaaS）：覆盖硬件层和基础设施层。
- 平台即服务（PaaS）：覆盖平台层。
- 软件即服务（SaaS）：覆盖应用层。

### 边缘 - 云架构

#### 核心本质

部署在互联网上的系统，服务器位于网络边缘（企业网络与互联网的边界）。

#### 边缘计算的定义

边缘计算将服务部署在 “网络边缘”（通常是企业网络与互联网的边界，由互联网服务提供商 ISP 提供）。例如，大学校园的各个建筑有本地网络，连接到校园网，校园网部署存储、计算、安全、教学等本地服务，这些服务的流量主要在校园网内，形成典型的边缘基础设施。

#### 边缘与云的连接

本地服务器可连接到其他大学的服务器或远程服务器，通常通过逻辑集中式基础设施（云或区域数据中心）共享服务，这种接近云基础设施的边缘架构称为雾计算（Fog Computing）。

#### 边缘计算的必要性

尽管智能终端可直接连接云服务，但边缘基础设施仍有其价值，常见（部分存在误解）的理由包括：

- 延迟和带宽：对增强现实 / 虚拟现实等实时应用至关重要，许多人低估了云服务的延迟和带宽限制。
- 可靠性：通常认为云连接不可靠（实际可能并非如此），但部分关键场景需要极高的连接保障。
- 安全性和隐私性：默认认为本地资产更易保护（实际通常不成立），但在云中安全处理数据操作可能比在组织内部更复杂。

#### 边缘编排的挑战

管理边缘资源比管理云资源更复杂：

- 资源分配：需保证服务执行所需的资源可用性。
- 服务部署：需决定服务的部署时间和位置（对移动应用尤为重要）。
- 边缘选择：需决定提供服务时使用哪个边缘基础设施，最近的不一定是最优的。

### 区块链架构

#### 核心工作原理

区块链系统用于记录交易，交易不仅限于货币（还包括身份证注册、资源使用跟踪、电子投票、健康记录共享等）。与传统银行作为可信第三方不同，区块链的设计假设参与方原则上不可信，交易记录在公开账本中，所有参与方可查看并验证交易有效性（如数字硬币交易中，可通过查询所有历史交易验证硬币是否已被花费）。

#### 交易处理步骤

1. 发起交易：Alice 向 Bob 转账 10 美元，向所有区块链参与方广播交易意图，志愿者验证该交易。
2. 区块打包：为提高效率，验证者将多个交易分组为一个区块。
3. 区块确认与上链：若区块中的交易有效，验证者通过加密保护区块防止篡改，将不可变的区块追加到已验证交易的区块链中，并向所有参与方广播该区块。

#### 关键特性

- 不可篡改的链式结构：区块按顺序组成不可伪造的追加式链条，每个区块不可修改，任何篡改都会被检测到。
- 大规模复制：区块不可修改，适合广泛复制，所有参与方在本地存储区块链副本，便于验证。
- 核心难点：决定谁有权将区块追加到链条中，需达成共识，否则可能导致验证者重复工作。

#### 区块链的组织形式

1. 集中式解决方案：由可信第三方验证交易（不符合区块链避免单一可信第三方的设计目标）。
2. 分布式解决方案（授权型）：由预选的小型进程组充当可信第三方，无需信任单个服务器，只要约三分之二的服务器按规范运行即可，实际中通常支持数十台服务器。
3. 去中心化解决方案（无授权型）：所有参与节点共同达成共识，无任何分布式第三方，节点通过领导者选举确定谁有权追加区块。大规模、公平、稳健、安全的去中心化领导者选举极具挑战性。